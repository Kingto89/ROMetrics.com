<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MMT Trainer ‚Äî Side Notes (Hard‚ÄëWired Pose)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{
  --bg:#f1f5f9; --panel:#ffffff; --line:#cbd5e1; --ctrl:#e2e8f0;
  --text:#0f172a; --muted:#64748b; --primary:#0d9488; --accent:#facc15;
}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}

.panel{position:fixed;left:25px;top:12px;width:380px;max-height:92vh;z-index:100;background:var(--panel);
  border:1px solid var(--line);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.15);display:flex;flex-direction:column;overflow:hidden}
.dragbar{cursor:move;background:var(--ctrl);border-bottom:1px solid var(--line);padding:8px 12px;font-weight:700;display:flex;align-items:center;gap:8px}
.dragbar .hint{margin-left:auto;font-size:12px;color:var(--muted)}
.content{padding:12px;overflow:auto}
label{display:block;font-size:12px;margin-top:8px;color:var(--muted)}
select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:var(--ctrl);border:1px solid var(--line);color:var(--text)}
.row{display:flex;gap:8px}.row>button,.row>select{flex:1}
.mini{padding:6px 10px;border-radius:8px;background:var(--ctrl);border:1px solid var(--line)}
.lockOn{background:#0b3a1f;border-color:#16a34a;color:#fff}
#msg{position:fixed;bottom:10px;left:12px;background:var(--panel);border:1px solid var(--line);border-radius:8px;padding:6px 10px;font-size:12px;z-index:25;color:var(--text)}
#log{display:none;background:var(--ctrl);border:1px solid var(--line);min-height:90px;max-height:130px;overflow:auto;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap;color:var(--text)}

#notePanel{position:fixed;top:16px;right:16px;width:min(420px,46vw);max-height:70vh;display:none;z-index:140;
  background:#e2e8f0;border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 32px rgba(0,0,0,.25);
  display:flex;flex-direction:column;overflow:hidden}
.note-head{display:flex;align-items:center;gap:8px;padding:10px 12px;background:#dbe4ee;border-bottom:1px solid var(--line)}
.note-head h3{margin:0;font-size:16px;font-weight:800;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.note-tabs{display:flex;gap:8px}
.note-tabs button{padding:6px 10px;border-radius:8px;border:1px solid var(--line);background:#fff}
.note-tabs button.active{background:#0d9488;color:#fff;border-color:#0d9488}
.note-body{padding:12px;overflow:auto;background:#fff}
.note-close{border-radius:8px;border:1px solid var(--line);padding:6px 10px;background:#fff}
@media (max-width: 720px){
  #notePanel{right:8px;left:8px;width:auto;max-height:60vh}
}
.hide{display:none !important;}
</style>
</head>
<body>

<div class="panel" id="panel">
  <div class="dragbar" id="dragbar">üí™ MMT Trainer <span class="hint">drag me</span></div>
  <div class="content">
    <label>MMT Test & Muscle</label>
    <select id="actionSel">
      <option value="">(Select a test to begin‚Ä¶)</option>
      <optgroup label="Cervical & Capital">
        <option value="Capital_Extension">Capital Extension (Rectus Capitis Posterior Major, Obliquus Capitis Superior, Splenius Capitis)</option>
        <option value="Cervical_Extension">Cervical Extension (Semispinalis Cervicis, Splenius Cervicis, Longissimus Cervicis)</option>
        <option value="Capital_Flexion">Capital Flexion ‚Äî Chin Tuck (Longus Capitis, Rectus Capitis Anterior, Anterior Scalene)</option>
        <option value="Cervical_Flexion">Cervical Flexion (Sternocleidomastoid, Longus Colli, Anterior Scalene)</option>
        <option value="Single_SCM">Single SCM ‚Äî Anterolateral Flexion (SCM, Longus Capitis, Longus Colli)</option>
        <option value="Cervical_Rotation">Cervical Rotation (SCM‚Äîcontralateral; Splenius Capitis‚Äîipsilateral; Longissimus Capitis‚Äîipsilateral)</option>
      </optgroup>
      <optgroup label="Scapula">
        <option value="Serratus_Anterior">Scapular Abduction & Upward Rotation (Serratus Anterior)</option>
        <option value="Upper_Trapezius">Scapular Elevation (Upper Trapezius, Levator Scapulae)</option>
        <option value="Middle_Trapezius">Scapular Adduction / Retraction (Middle Trapezius)</option>
        <option value="Rhomboids">Scapular Adduction + Downward Rotation (Rhomboids)</option>
        <option value="Latissimus_Dorsi">Latissimus Dorsi (shoulder depression/extension pattern)</option>
      </optgroup>
      <optgroup label="Shoulder">
        <option value="Anterior_Deltoid">Shoulder Flexion (Anterior Deltoid, Coracobrachialis)</option>
        <option value="Posterior_Deltoid">Shoulder Extension (Posterior Deltoid, Lat, Teres Major)</option>
        <option value="Middle_Deltoid">Shoulder Abduction (Middle Deltoid, Supraspinatus)</option>
        <option value="Infraspinatus">Shoulder External Rotation (Infraspinatus, Teres Minor)</option>
        <option value="Subscapularis">Shoulder Internal Rotation (Subscapularis, Teres Major, Pec Major, Lat)</option>
      </optgroup>
      <optgroup label="Trunk & Pelvis - Grading Exception">
        <option value="Trunk_Ext_Lumbar">Trunk Extension ‚Äî Lumbar (Erector Spinae)</option>
        <option value="Trunk_Ext_Thoracic">Trunk Extension ‚Äî Thoracic (Erector Spinae)</option>
        <option value="Trunk_Flexion">Trunk Flexion ‚Äî Rectus Abdominis</option>
        <option value="Trunk_Rotation">Trunk Rotation ‚Äî External & Internal Obliques</option>
        <option value="Pelvic_Elevation">Pelvic Elevation (Hip Hike) ‚Äî Quadratus Lumborum</option>
      </optgroup>
      <optgroup label="Elbow">
        <option value="Biceps_Brachii">Elbow Flexion ‚Äî Biceps Brachii (supinated)</option>
        <option value="Brachialis">Elbow Flexion ‚Äî Brachialis (pronated)</option>
        <option value="Brachioradialis">Elbow Flexion ‚Äî Brachioradialis (neutral)</option>
        <option value="Triceps_Brachii">Elbow Extension ‚Äî Triceps Brachii</option>
      </optgroup>
      <optgroup label="Wrist">
        <option value="ECRL">Wrist Extension ‚Äî Extensor Carpi Radialis Longus (ECRL)</option>
        <option value="ECRB">Wrist Extension ‚Äî Extensor Carpi Radialis Brevis (ECRB)</option>
        <option value="ECU">Wrist Extension ‚Äî Extensor Carpi Ulnaris (ECU)</option>
        <option value="FCR">Wrist Flexion ‚Äî Flexor Carpi Radialis (FCR)</option>
        <option value="FCU">Wrist Flexion ‚Äî Flexor Carpi Ulnaris (FCU)</option>
      </optgroup>
      <optgroup label="Hip">
        <option value="Iliopsoas">Hip Flexion (Iliopsoas)</option>
        <option value="Glute_Max">Hip Extension (Glute Max, Hamstrings)</option>
        <option value="Glute_Med">Hip Abduction (Glute Med, Glute Min)</option>
        <option value="Hip_ER">Hip External Rotation</option>
        <option value="Hip_IR">Hip Internal Rotation</option>
      </optgroup>
      <optgroup label="Knee">
        <option value="Hamstrings">Knee Flexion (Hamstrings)</option>
        <option value="Quadriceps">Knee Extension (Quadriceps)</option>
      </optgroup>
      <optgroup label="Ankle & Foot -  Grading Exception for Gastroc">
        <option value="Tibialis_Anterior">Dorsiflexion + Inversion (Tibialis Anterior)</option>
        <option value="Foot_Eversion_PF">Foot Eversion + Plantarflexion (Fibularis Longus, Fibularis Brevis)</option>
        <option value="Ankle_Dorsiflexion">Ankle Dorsiflexion (Tibialis Anterior; EDL/EHL assist)</option>
        <option value="Gastrocnemius">Plantar Flexion (Gastrocnemius, Soleus)</option>
      </optgroup>
    </select>

    <div class="row" style="margin-top:10px;">
      <button id="startTestBtn" class="mini">‚ñ∂Ô∏è Start Test </button>
      <button id="showMMT" class="mini">üìå MMT Placement</button>
    </div>

    <div class="row" style="align-items:center; margin-top:10px;">
      <div style="flex:1;">
        <label>Test Grade Selection</label>
        <select id="grade-main" name="grade-main">
          <option value="3">Grade 3 - 5 (Full ROM / Resistance: none, Mod, Max)</option>
          <option value="2">Grade 2 (Full ROM / Gravity Eliminated)</option>
          <option value="1">Grade 1 (Trace Contraction)</option>
          <option value="0">Grade 0 (No Contraction)</option>
        </select>
      </div>
      <div style="flex:1;">
        <label>Grading Exceptions</label>
        <select id="GradingExceptions" name="GradingExceptions">
          <option value="5">Grade 5 (Full ROM / Maximum Resistance)</option>
          <option value="4">Grade 4 (Full ROM / Moderate Resistance)</option>
          <option value="3">Grade 3 (Full ROM / No Resistance)</option>
          <option value="2">Grade 2 (Full ROM / Gravity Eliminated)</option>
          <option value="1">Grade 1 (Trace Contraction)</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="testButton" disabled>
        <div id="resistanceFill"></div>
        <span id="resistanceText">Hold to Apply Resistance (4/5)</span>
      </button>
    </div>
    <p id="instructionText">Hold for 1s (Grade 4), Hold for 2s (Grade 5).</p>

    <label>Model Control</label>
    <div class="row">
      <button id="lock3D" class="mini">üîì 3D: Unlocked</button>
      <button id="zeroAll" class="mini" title="Reset to anatomic baseline">Zero All</button>
    </div>
  </div>
</div>

<div id="msg">Loading‚Ä¶</div>
<canvas id="c"></canvas>

<!-- Right-side notes panel -->
<div id="notePanel" class="hide">
  <div class="note-head">
    <h3 id="noteTitle">MMT Instructions</h3>
    <div class="note-tabs">
      <button id="tabHigh" class="active">Grades 3‚Äì5</button>
      <button id="tabLow">Grades 0‚Äì2</button>
    </div>
    <button class="note-close" id="closeNote">Close ‚úï</button>
  </div>
  <div class="note-body" id="noteBody">Loading‚Ä¶</div>
</div>

<script>
  // Use your live model path (uploaded in your repo)
  window.ROMETRICS_MODEL_URL = "https://kingto89.github.io/ROMetrics.com/assets/Roma_ROMetrics.glb";
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

/* ==== Hard-wired numeric pose (edit these) ==== */
const POSE = {
  x: -0.10,   // left(-) / right(+)
  y: 0.00,   // down(-) / up(+)
  z: 0.70,  // back(-) / front(+)
  ryDeg: 30,  // rotation 0‚Äì360
  s: 1.15,   // scale
  seated: false // true = sit legs
};

/* ==== Error surfacing ==== */
window.addEventListener('error', (e) => {
  const m = document.getElementById("msg");
  if (m) m.textContent = `‚ö†Ô∏è ${e.message}`;
});

/* ==== UI refs ==== */
const $ = (id)=>document.getElementById(id);
const canvas = $("c");
const logEl = $("log");
const log = (t) => { if(logEl){ logEl.textContent += t + "\\n"; logEl.scrollTop = logEl.scrollHeight; } };

const actionSel = $("actionSel");
const startTestBtn = $("startTestBtn");
const showMMT = $("showMMT");
const testButton = $("testButton");
const resistanceFill = $("resistanceFill");
const resistanceText = $("resistanceText");
const instructionText = $("instructionText");
const gradeMain = $("grade-main");
const gradeExceptions = $("GradingExceptions");  

/* ==== Start Test Button Glow Fix ==== */
startTestBtn.addEventListener('click', () => {
  startTestBtn.classList.add('lockOn');
  setTimeout(() => startTestBtn.classList.remove('lockOn'), 300);
});

/* ==== THREE setup ==== */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf1f5f9);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 200);
camera.position.set(1.8,1.6,3.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = .08;
controls.minDistance=.6; controls.maxDistance=20;
controls.target.set(0,1.05,0); 

/* Lights */
scene.add(new THREE.HemisphereLight(0xffffff, 0x8ca0b3, 0.8));
const key = new THREE.DirectionalLight(0xffffff, 1.1);
key.position.set(3.5,5,3.5);
key.castShadow = true;
key.shadow.mapSize.set(2048,2048);
key.shadow.camera.near=0.1; key.shadow.camera.far=50;
key.shadow.camera.left=-10; key.shadow.camera.right=10;
key.shadow.camera.top=10; key.shadow.camera.bottom=-10;
scene.add(key);

/* ==== ROOM GEOMETRY (simple eval room) ==== */
const room = new THREE.Group();
scene.add(room);

// Floor (vinyl)
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(12, 12),
  new THREE.MeshStandardMaterial({ color: 0xe2e8f0, roughness:0.9, metalness:0 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
room.add(floor);

// Walls
const wallMat = new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 1, metalness: 0 });
const backWall = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), wallMat);
backWall.position.set(0, 1.5, -6);
room.add(backWall);
const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), wallMat);
leftWall.rotation.y = Math.PI/2;
leftWall.position.set(-6, 1.5, 0);
room.add(leftWall);

// Long blue table (extended)
const TABLE_HEIGHT = 0.46;
const TABLE_THICK = 0.08;
const TABLE_W = 0.7;
const TABLE_D = 2.2; // Long enough
const tableTop = new THREE.Mesh(
  new THREE.BoxGeometry(TABLE_W, TABLE_THICK, TABLE_D),
  new THREE.MeshStandardMaterial({ color: 0x1e3a8a, roughness:0.85, metalness:0.05 }) // deep blue
);
tableTop.position.set(0, TABLE_HEIGHT, 0.35);
tableTop.castShadow = true; tableTop.receiveShadow = true;
room.add(tableTop);

// Table base (simple box legs)
const base = new THREE.Mesh(
  new THREE.BoxGeometry(TABLE_W*0.6, TABLE_HEIGHT, TABLE_D*0.8),
  new THREE.MeshStandardMaterial({ color: 0x374151, roughness:0.9, metalness:0.05 })
);
base.position.set(0, TABLE_HEIGHT/2, 0.35);
base.castShadow = true; base.receiveShadow = true;
room.add(base);

// Cabinet
const cabinet = new THREE.Mesh(
  new THREE.BoxGeometry(1.0, 0.9, 0.45),
  new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness:0.8 })
);
cabinet.position.set(-1.6, 0.45, -0.6);
cabinet.castShadow = true; cabinet.receiveShadow = true;
room.add(cabinet);

// Stool
const stoolSeat = new THREE.Mesh(
  new THREE.CylinderGeometry(0.18, 0.18, 0.06, 24),
  new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness:0.8 })
);
stoolSeat.position.set(0.95, 0.52, -0.2);
stoolSeat.castShadow = true; stoolSeat.receiveShadow = true;
room.add(stoolSeat);
const stoolLeg = new THREE.Mesh(
  new THREE.CylinderGeometry(0.03, 0.03, 0.5, 16),
  new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness:0.8 })
);
stoolLeg.position.set(0.95, 0.25, -0.2);
stoolLeg.castShadow = true; stoolLeg.receiveShadow = true;
room.add(stoolLeg);

// Shadow catcher slightly above floor to enhance contact shadows
const shadowCatch = new THREE.Mesh(new THREE.PlaneGeometry(6,6), new THREE.ShadowMaterial({ opacity:0.4 }));
shadowCatch.rotation.x = -Math.PI/2;
shadowCatch.position.y = 0.001;
shadowCatch.receiveShadow = true;
room.add(shadowCatch);
 // ---- View preset: room yaw + camera distance (ONE BLOCK) ----
(() => {
  // Turn the whole room left/right (negative = left, positive = right)
  const ROOM_YAW_DEG = -70;
  room.rotation.y = degToRad(ROOM_YAW_DEG);

  // Zoom preset: set camera distance from the controls target
  function setCameraDistance(d){
    const dir = new THREE.Vector3()
      .subVectors(camera.position, controls.target)
      .normalize();
    camera.position.copy(controls.target).addScaledVector(dir, d);
  }
  setCameraDistance(4.8); // bigger = farther, smaller = closer
})();

/* === Anatomic preset ‚Äî simple like goniometer index === */
const ANAT = { add:-32, ps:-2, wps:-73 };
const AXIS_MAP = {
  sh_fe_l:      'x',  sh_fe_r:      'x',
  sh_aa_l:      'z',  sh_aa_r:     '-z',
  sh_irer_l:    'y',  sh_irer_r:    'y',
  el_fe_l:      'x',  el_fe_r:      'x',
  fa_ps_l:      'y',  fa_ps_r:      'y',
  wr_ps_l:      'y',  wr_ps_r:      'y',
  wr_fe_l:      'x',  wr_fe_r:      'x',
  wr_ru_l:      'z',  wr_ru_r:      'z',
  hip_fe_l:     'x',  hip_fe_r:     'x',
  hip_aa_l:     'z',  hip_aa_r:     'z',
  hip_irer_l:   'y',  hip_irer_r:   'y',
  knee_fe_l:    'x',  knee_fe_r:    'x',
  ankle_dfpf_l: 'x',  ankle_dfpf_r: 'x',
  foot_invev_l: 'z',  foot_invev_r: 'z',
  trunk_fe:     'x',
  trunk_lat:    'z',
  trunk_rot:    'y',
  cerv_fe:      'x',
  cerv_lat:     'z',
  cerv_rot:     'y',
  clavicle_L:   'z',
  clavicle_R:  '-z'
};
  

function getBone(name){
  return skeleton?.bones.find(b => b.name === name) || null;
}
function setDegAxis(bone, axis, deg){
  if(!bone) return;
  const q0 = initialBoneRot.get(bone);
  if(q0) bone.quaternion.copy(q0);        // reset to baseline
  const r = THREE.MathUtils.degToRad(deg);
  if(axis==='x') bone.rotateX(r);
  else if(axis==='y') bone.rotateY(r);
  else bone.rotateZ(r);
}

// ONE simple function that sets both sides (like your gonio index)
// NOTE: this assumes arm bone names like "upperarm_L/R", "forearm_L/R", "hand_L/R".
// If your rig uses "wrist_L/R" instead of "hand_L/R", change those two names below.
function applyAnatomicBaseline(){
  const shL = getBone('upperarm_L'), shR = getBone('upperarm_R'); // shoulder ab/ad on Z
  const faL = getBone('forearm_L'),  faR = getBone('forearm_R');  // forearm PS on Y
  const wrL = getBone('hand_L'),     wrR = getBone('hand_R');     // wrist PS on Y (use 'wrist_*' if needed)

  setDegAxis(shL, 'z', ANAT.add);
  setDegAxis(shR, 'z', -ANAT.add);

  setDegAxis(wrL, 'y', ANAT.wps);
  setDegAxis(wrR, 'y', -ANAT.wps);   
}
  
  
/* ==== Loader ==== */
const loader = new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
const ktx2  = new KTX2Loader();  ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

let model=null, skeleton=null;
const initialBoneRot = new Map();
let GLOBAL_PF_DEG = 0; // shared plantarflex angle for both feet

// Reset all bones back to stored baseline
function resetAllBones(){
  if (!skeleton) return;
  skeleton.bones.forEach(b=>{
    const q0 = initialBoneRot.get(b);
    if (q0) b.quaternion.copy(q0);
  });
}

// Tests that use the GradingExceptions dropdown to decide high vs low family
const EXCEPTION_TESTS = new Set([
  "Trunk_Ext_Lumbar",
  "Trunk_Ext_Thoracic",
  "Trunk_Flexion",
  "Trunk_Rotation",
  "Pelvic_Elevation",
  "Gastrocnemius"
]);

// For each test: which coarse body position to use for high (3‚Äì5) vs low (0‚Äì2) grades
// Modes: 'anatomic', 'seated', 'supine', 'prone', 'side_lying', 'gastroc'
const TEST_POSITION = {
  // Cervical & Capital
  Capital_Extension:   { high: "prone",      low: "supine"      },
  Cervical_Extension:  { high: "prone",      low: "supine"      },
  Capital_Flexion:     { high: "supine",     low: "supine"      },
  Cervical_Flexion:    { high: "supine",     low: "side_lying"  },
  Single_SCM:          { high: "supine",     low: "supine"      },
  Cervical_Rotation:   { high: "supine",     low: "supine"      },

  // Scapula
  Serratus_Anterior:   { high: "seated",     low: "seated"      },
  Upper_Trapezius:     { high: "seated",     low: "prone"       },
  Middle_Trapezius:    { high: "prone",      low: "prone"       },
  Rhomboids:           { high: "prone",      low: "prone"       },
  Latissimus_Dorsi:    { high: "prone",      low: "side_lying"  },

  // Shoulder
  Anterior_Deltoid:    { high: "seated",     low: "side_lying"  },
  Posterior_Deltoid:   { high: "prone",      low: "side_lying"  },
  Middle_Deltoid:      { high: "seated",     low: "supine"      },
  Infraspinatus:       { high: "seated",     low: "seated"      }, // table-supported ER
  Subscapularis:       { high: "seated",     low: "seated"      },

  // Trunk & Pelvis (grading exceptions)
  Trunk_Ext_Lumbar:    { high: "prone",      low: "prone"       },
  Trunk_Ext_Thoracic:  { high: "prone",      low: "prone"       },
  Trunk_Flexion:       { high: "supine",     low: "supine"      },
  Trunk_Rotation:      { high: "supine",     low: "supine"      },
  Pelvic_Elevation:    { high: "supine",     low: "supine"      },

  // Elbow
  Biceps_Brachii:      { high: "seated",     low: "side_lying"  },
  Brachialis:          { high: "seated",     low: "side_lying"  },
  Brachioradialis:     { high: "seated",     low: "side_lying"  },
  Triceps_Brachii:     { high: "seated",     low: "seated"      },

  // Wrist
  ECRL:                { high: "seated",     low: "seated"      },
  ECRB:                { high: "seated",     low: "seated"      },
  ECU:                 { high: "seated",     low: "seated"      },
  FCR:                 { high: "seated",     low: "seated"      },
  FCU:                 { high: "seated",     low: "seated"      },

  // Hip
  Iliopsoas:           { high: "seated",     low: "side_lying"  },
  Glute_Max:           { high: "prone",      low: "side_lying"  },
  Glute_Med:           { high: "side_lying", low: "supine"      },
  Hip_ER:              { high: "seated",     low: "supine"      },
  Hip_IR:              { high: "seated",     low: "supine"      },

  // Knee
  Hamstrings:          { high: "prone",      low: "side_lying"  },
  Quadriceps:          { high: "seated",     low: "side_lying"  },

  // Ankle & Foot
  Tibialis_Anterior:   { high: "seated",     low: "supine"      }, // dorsiflex+inv
  Foot_Eversion_PF:    { high: "seated",     low: "supine"      },
  Ankle_Dorsiflexion:  { high: "seated",     low: "supine"      },
  Gastrocnemius:       { high: "gastroc",    low: "side_lying"  }
};

// Decide if we're in the high (3‚Äì5) or low (0‚Äì2) family for a given test
// Per-test pose overrides (absolute position + rotation) keyed by "TestKey:high" / "TestKey:low"
const POSE_OVERRIDES = {
  // Paste the console lines from the tuner in here, like:
  // "Capital_Extension:high": { x:0.000, y:0.480, z:0.350, rx:1.571, ry:0.523, rz:0.000 },
  // "Capital_Extension:low":  { x:...,   y:...,   z:...,   rx:...,   ry:...,   rz:... },
};

let CURRENT_BODY_TEST = null;
let CURRENT_BODY_BUCKET = "high"; // "high" or "low"
  
function getGradeBucketForTest(testKey){
  // Trunk & gastroc use GradingExceptions dropdown
  if (EXCEPTION_TESTS.has(testKey)){
    if (!gradeExceptions) return "high";
    const g = Number(gradeExceptions.value || "3");
    return (g >= 3 ? "high" : "low");
  }

  // All other tests use grade-main (3‚Äì5 vs 0‚Äì2)
  if (!gradeMain) return "high";
  const gm = Number(gradeMain.value || "3");
  return (gm >= 3 ? "high" : "low");
}

/** Global plantarflexion for both feet */
function applyGlobalPF(){
  if (!skeleton) return;

  const footL = getBone("foot_L");
  const footR = getBone("foot_R");

  // Reset feet to their baseline before applying PF
  [footL, footR].forEach(b => {
    if (!b) return;
    const q0 = initialBoneRot.get(b);
    if (q0) b.quaternion.copy(q0);
  });

  if (!GLOBAL_PF_DEG) return; // nothing to do if 0¬∞

  const r = degToRad(GLOBAL_PF_DEG);
  // If toes go the wrong way, flip sign here
  if (footL) footL.rotateX(-r);
  if (footR) footR.rotateX(-r);
}

// Coarse body-mode: align to bed/cabinet but don't set specific joint test angles
function setBodyMode(mode){
  if (!model || !skeleton) return;

  // Always start from your standing anatomic baseline
  resetAllBones();
  applyAnatomicBaseline();

  // Defaults: your original standing pose in front of bed
  let posX = POSE.x;
  let posY = POSE.y;
  let posZ = POSE.z;
  let rotX = 0;
  let rotY = degToRad(POSE.ryDeg);
  let rotZ = 0;

  if (mode === "seated"){
    // Short sitting at edge of blue table
    const edgeZ = tableTop.position.z + (TABLE_D / 2) - 0.25;
    posX = 0;
    posY = TABLE_HEIGHT + 0.02;
    posZ = edgeZ;
    rotX = 0;
    rotY = degToRad(POSE.ryDeg);
    seatPoseOnlyLegs();

  } else if (mode === "supine"){
    // Supine on bed, centered
    posX = 0;
    posY = TABLE_HEIGHT + TABLE_THICK / 2 + 0.04;
    posZ = tableTop.position.z;
    rotX = Math.PI / 2;
    rotY = degToRad(POSE.ryDeg);

  } else if (mode === "prone"){
    // Prone on bed, centered
    posX = 0;
    posY = TABLE_HEIGHT + TABLE_THICK / 2 + 0.04;
    posZ = tableTop.position.z;
    rotX = Math.PI / 2;
    rotY = degToRad(POSE.ryDeg + 180);

  } else if (mode === "side_lying"){
    // Side-lying on bed (rough: lying with trunk rotated)
    posX = 0;
    posY = TABLE_HEIGHT + TABLE_THICK / 2 + 0.04;
    posZ = tableTop.position.z;
    rotX = Math.PI / 2;
    rotY = degToRad(POSE.ryDeg);
    rotZ = Math.PI / 2; // roll onto side

  } else if (mode === "gastroc"){
    // Standing by cabinet for heel raises
    const standZ = cabinet.position.z - 0.5;
    posX = cabinet.position.x;
    posY = 0;    // floor
    posZ = standZ;
    rotX = 0;
    rotY = 0;    // face cabinet

  } else {
    // 'anatomic' or unknown ‚Üí your original standing pose
    posX = POSE.x;
    posY = POSE.y;
    posZ = POSE.z;
    rotX = 0;
    rotY = degToRad(POSE.ryDeg);
    rotZ = 0;
  }

  // Apply any saved override for this test + family (high/low)
  const key = CURRENT_BODY_TEST && CURRENT_BODY_BUCKET
    ? `${CURRENT_BODY_TEST}:${CURRENT_BODY_BUCKET}`
    : null;

  if (key && POSE_OVERRIDES[key]){
    const o = POSE_OVERRIDES[key];
    posX = o.x;
    posY = o.y;
    posZ = o.z;
    rotX = o.rx;
    rotY = o.ry;
    rotZ = o.rz;
  }

  model.position.set(posX, posY, posZ);
  model.rotation.set(rotX, rotY, rotZ);

  // Re-apply global plantarflexion to both feet
  applyGlobalPF();
}



function applyBodyPositionFromSelection(){
  if (!model || !skeleton) return;
  const key = actionSel?.value;
  if (!key) return;

  const family = TEST_POSITION[key] || { high:"anatomic", low:"anatomic" };
  const bucket = getGradeBucketForTest(key); // "high" or "low"
  const mode = bucket === "low" ? (family.low || "anatomic")
                                : (family.high || "anatomic");

  CURRENT_BODY_TEST = key;
  CURRENT_BODY_BUCKET = bucket;

  setBodyMode(mode);
}

/* ==== Utilities ==== */
function degToRad(d){ return d * Math.PI / 180; }
function seatPoseOnlyLegs(){
  if(!skeleton) return;
  const get = (n)=> skeleton.bones.find(b => b.name === n);
  const thighL = get("thigh_L"), thighR = get("thigh_R"), calfL = get("calf_L"), calfR = get("calf_R");
  [thighL,thighR,calfL,calfR].forEach(b=>{
    if(!b) return;
    const q0 = initialBoneRot.get(b);
    if (q0) b.quaternion.copy(q0);
  });
  const rad = THREE.MathUtils.degToRad;
  if (thighL) thighL.rotateX(rad(85));
  if (thighR) thighR.rotateX(rad(85));
  if (calfL)  calfL.rotateX(rad(-90));
  if (calfR)  calfR.rotateX(rad(-90));
}

/* ==== Load model ==== */
function addModel(gltf){
  model = gltf.scene;
  model.traverse(o=>{
    if (o.isMesh){ o.castShadow=true; o.receiveShadow=true; }
    if (o.isSkinnedMesh && !skeleton) skeleton = o.skeleton;
  });

  // store baseline bone rotations
  if (skeleton){
    skeleton.bones.forEach(b => initialBoneRot.set(b, b.quaternion.clone()));
    applyAnatomicBaseline();
  }

  // Apply hard-wired numeric transform (no saving, no snapping)
  model.scale.set(POSE.s, POSE.s, POSE.s);
  model.position.set(POSE.x, POSE.y, POSE.z);
  model.rotation.set(0, degToRad(POSE.ryDeg), 0);
  if (POSE.seated) seatPoseOnlyLegs();

  scene.add(model);
  $("msg").textContent = "‚úÖ Model loaded";
}

const MODEL_CANDIDATES = [
  window.ROMETRICS_MODEL_URL,
  "assets/Roma_ROMetrics.glb",
  new URL("assets/Roma_ROMetrics.glb", document.baseURI).href
].filter(Boolean);

function tryNextModelUrl(index){
  if(index >= MODEL_CANDIDATES.length){
    $("msg").textContent = "‚ö†Ô∏è Could not load model from any path.";
    return;
  }
  const url = MODEL_CANDIDATES[index];
  $("msg").textContent = "Loading model‚Ä¶ " + url;
  loader.load(
    url,
    (gltf)=> addModel(gltf),
    (xhr)=>{
      const pct = xhr.lengthComputable ? Math.min(100, Math.round(100*xhr.loaded/xhr.total)) : null;
      $("msg").textContent = pct!==null ? `Loading ${pct}%` : "Loading‚Ä¶";
    },
    ()=> tryNextModelUrl(index+1)
  );
}

tryNextModelUrl(0);  

/* ==== Wire UI ==== */
$("lock3D").onclick = () => {
  controls.enabled = !controls.enabled;
  const btn = $("lock3D");
  btn.textContent = (!controls.enabled ? "üîí 3D: Locked" : "üîì 3D: Unlocked");
  btn.classList.toggle('lockOn', !controls.enabled);
};
$("zeroAll").onclick = () => {
  // Reset bones and return to your original standing anatomic pose
  resetAllBones();
  applyAnatomicBaseline();
  if (model){
    model.position.set(POSE.x, POSE.y, POSE.z);
    model.rotation.set(0, degToRad(POSE.ryDeg), 0);
  }
};

actionSel.addEventListener("change", () => {
  applyBodyPositionFromSelection();
  if (poseTunerEl && poseTunerEl.updateLabels) poseTunerEl.updateLabels();
});

gradeMain.addEventListener("change", () => {
  if (actionSel.value){
    applyBodyPositionFromSelection();
    if (poseTunerEl && poseTunerEl.updateLabels) poseTunerEl.updateLabels();
  }
});

if (gradeExceptions){
  gradeExceptions.addEventListener("change", () => {
    if (actionSel.value){
      applyBodyPositionFromSelection();
      if (poseTunerEl && poseTunerEl.updateLabels) poseTunerEl.updateLabels();
    }
  });
}
  


/* ==== Side panel + Markdown loading ==== */
const notePanel = document.getElementById('notePanel');
const noteTitle = document.getElementById('noteTitle');
const noteBody  = document.getElementById('noteBody');
const tabHigh   = document.getElementById('tabHigh'); // 3‚Äì5
const tabLow    = document.getElementById('tabLow');  // 0‚Äì2
const closeNote = document.getElementById('closeNote');

// GitHub RAW URLs for the two docs
const MD_HIGH = "https://raw.githubusercontent.com/Kingto89/ROMetrics.com/main/mmt/rometrics_mmt_threetofive.md";
const MD_LOW  = "https://raw.githubusercontent.com/Kingto89/ROMetrics.com/main/mmt/rometrics_mmt_zerototwo.md";

// Map select values to readable headings to find in MD
const TEST_TO_HEADING = {
  Serratus_Anterior: "Scapular Abduction & Upward Rotation",
  Upper_Trapezius: "Scapular Elevation",
  Middle_Trapezius: "Scapular Adduction / Retraction",
  Rhomboids: "Scapular Adduction + Downward Rotation",
  Latissimus_Dorsi: "Latissimus Dorsi",
  Anterior_Deltoid: "Shoulder Flexion",
  Posterior_Deltoid: "Shoulder Extension",
  Middle_Deltoid: "Shoulder Abduction",
  Infraspinatus: "Shoulder External Rotation",
  Subscapularis: "Shoulder Internal Rotation",
  Biceps_Brachii: "Elbow Flexion ‚Äî Biceps Brachii",
  Brachialis: "Elbow Flexion ‚Äî Brachialis",
  Brachioradialis: "Elbow Flexion ‚Äî Brachioradialis",
  Triceps_Brachii: "Elbow Extension",
  ECRL: "Wrist Extension ‚Äî ECRL",
  ECRB: "Wrist Extension ‚Äî ECRB",
  ECU: "Wrist Extension ‚Äî ECU",
  FCR: "Wrist Flexion ‚Äî Flexor Carpi Radialis",
  FCU: "Wrist Flexion ‚Äî Flexor Carpi Ulnaris",
  Iliopsoas: "Hip Flexion",
  Glute_Max: "Hip Extension",
  Glute_Med: "Hip Abduction",
  Hip_ER: "Hip External Rotation",
  Hip_IR: "Hip Internal Rotation",
  Hamstrings: "Knee Flexion",
  Quadriceps: "Knee Extension",
  Tibialis_Anterior: "Foot Dorsiflexion + Inversion",
  Gastrocnemius: "Ankle Plantar Flexion"
};

function mdToHtml(md){
  // Tiny converter for headings/lists/bold/paragraphs
  return md
    .replace(/^### (.*)$/gm, "<h3>$1</h3>")
    .replace(/^## (.*)$/gm, "<h2>$1</h2>")
    .replace(/^\* (.*)$/gm, "<li>$1</li>")
    .replace(/^- (.*)$/gm, "<li>$1</li>")
    .replace(/(\n<li>.*<\/li>)+/g, m => `<ul>${m}</ul>`)
    .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
    .replace(/\n{2,}/g, "</p><p>")
    .replace(/^([^<\n].*)$/gm, "<p>$1</p>");
}

// Extract section starting with matching "## Heading" until next "##"
function extractSection(md, queryHeading){
  const lines = md.split(/\r?\n/);
  let start = -1;
  for (let i=0;i<lines.length;i++){
    if (lines[i].startsWith("## ") && lines[i].toLowerCase().includes(queryHeading.toLowerCase())){
      start = i; break;
    }
  }
  if (start === -1){
    return md; // fallback: show whole doc if not found
  }
  let end = lines.length;
  for (let j=start+1;j<lines.length;j++){
    if (lines[j].startsWith("## ")){ end = j; break; }
  }
  return lines.slice(start, end).join("\n");
}

async function loadNoteFile(which){
  const muscleKey = actionSel.value;
  if (!muscleKey){
    noteBody.innerHTML = "<p>Select a test first.</p>";
    return;
  }
  const heading = TEST_TO_HEADING[muscleKey] || muscleKey.replaceAll("_"," ");
  noteTitle.textContent = heading + " ‚Äî MMT Instructions";
  const url = (which === 'high') ? MD_HIGH : MD_LOW;
  noteBody.innerHTML = "Loading‚Ä¶";
  try{
    const res = await fetch(url);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    const section = extractSection(text, heading);
    noteBody.innerHTML = mdToHtml(section);
  }catch(e){
    noteBody.textContent = "Failed to load instructions.";
  }
}

function openNote(which='high'){
  tabHigh.classList.toggle('active', which==='high');
  tabLow.classList.toggle('active', which!=='high');
  notePanel.classList.remove('hide');
  notePanel.style.display = "flex";
  loadNoteFile(which);
}

showMMT.addEventListener('click', ()=> openNote('high'));
tabHigh.addEventListener('click', ()=> openNote('high'));
tabLow.addEventListener('click', ()=> openNote('low'));
closeNote.addEventListener('click', ()=> notePanel.classList.add('hide'));

 /* ===== Pose Tuner (dev) ‚Äî per-test high/low body transforms ===== */
let poseTunerEl = null;
let poseTunerVisible = true; // show on load so you can tune positions

function ensurePoseTuner(){
  if (poseTunerEl) return poseTunerEl;

  poseTunerEl = document.createElement('div');
  Object.assign(poseTunerEl.style, {
    position: 'fixed',
    right: '16px',
    top: '16px',
    zIndex: 50,
    background: 'rgba(8,13,26,.96)',
    border: '1px solid #334155',
    borderRadius: '12px',
    padding: '10px',
    width: '300px',
    color: '#e2e8f0',
    font: '12px/1.3 system-ui,Segoe UI,Roboto',
    boxShadow: '0 8px 28px rgba(0,0,0,.4)',
    display: 'none'
  });

  poseTunerEl.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
      <strong style="font-size:13px;">Pose Tuner (High / Low)</strong>
      <button id="poseTunerClose" title="Close" style="margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:16px;cursor:pointer;">‚úï</button>
    </div>
    <div style="font-size:11px;margin-bottom:6px;">
      <div><strong>Test:</strong> <span id="poseTunerTestLabel">(none)</span></div>
      <div><strong>Family:</strong> <span id="poseTunerBucketLabel">high</span></div>
    </div>

    <div style="border-top:1px solid #1f2933;margin:6px 0 8px 0;"></div>

    <label style="display:block;opacity:.85;">Position (meters)</label>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;margin-bottom:4px;">
      <div>
        <div style="opacity:.7;">X (left/right)</div>
        <div style="display:flex;gap:4px;">
          <button data-axis="x" data-delta="-0.02" class="mini">‚àí</button>
          <button data-axis="x" data-delta="0.02" class="mini">+</button>
        </div>
      </div>
      <div>
        <div style="opacity:.7;">Y (up/down)</div>
        <div style="display:flex;gap:4px;">
          <button data-axis="y" data-delta="-0.02" class="mini">‚àí</button>
          <button data-axis="y" data-delta="0.02" class="mini">+</button>
        </div>
      </div>
      <div>
        <div style="opacity:.7;">Z (front/back)</div>
        <div style="display:flex;gap:4px;">
          <button data-axis="z" data-delta="-0.02" class="mini">‚àí</button>
          <button data-axis="z" data-delta="0.02" class="mini">+</button>
        </div>
      </div>
    </div>

    <label style="display:block;opacity:.85;margin-top:4px;">Rotation (degrees)</label>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:4px;">
      <div>
        <div style="opacity:.7;">Yaw (turn left/right)</div>
        <div style="display:flex;gap:4px;">
          <button data-rot="y" data-delta="-5" class="mini">‚ü≤</button>
          <button data-rot="y" data-delta="5" class="mini">‚ü≥</button>
        </div>
      </div>
      <div>
        <div style="opacity:.7;">Pitch/Roll (face up/down/side)</div>
        <div style="display:flex;gap:4px;flex-wrap:wrap;">
          <button data-rot="x" data-delta="-5" class="mini">Pitch ‚àí</button>
          <button data-rot="x" data-delta="5" class="mini">Pitch +</button>
          <button data-rot="z" data-delta="-5" class="mini">Roll ‚àí</button>
          <button data-rot="z" data-delta="5" class="mini">Roll +</button>
        </div>
      </div>
    </div>

        <label style="display:block;opacity:.85;margin-top:4px;">Ankle Plantarflexion (both feet)</label>
    <div style="display:flex;gap:4px;margin-bottom:4px;align-items:center;">
      <button data-pf="-5" class="mini">Less PF</button>
      <button data-pf="5" class="mini">More PF</button>
      <span id="pfLabel" style="margin-left:auto;opacity:.7;">0¬∞</span>
    </div>


    <div style="display:flex;gap:8px;margin-top:8px;">
      <button id="poseTunerSnapBase" class="mini" style="flex:1;">Reset to Base Mode</button>
      <button id="poseTunerSave" class="mini" style="flex:1;background:#0f766e;border-color:#0f766e;color:#fff;">Save for Test</button>
    </div>

    <div style="margin-top:6px;font-size:10px;opacity:.7;">
      Uses current dropdown + grade to decide <em>which</em> pose (high vs low) you‚Äôre tuning.
    </div>
  `;

  document.body.appendChild(poseTunerEl);

  const labelTest   = poseTunerEl.querySelector('#poseTunerTestLabel');
  const labelBucket = poseTunerEl.querySelector('#poseTunerBucketLabel');
  const btnClose    = poseTunerEl.querySelector('#poseTunerClose');
  const btnSave     = poseTunerEl.querySelector('#poseTunerSave');
  const btnSnapBase = poseTunerEl.querySelector('#poseTunerSnapBase');
  const pfLabel = poseTunerEl.querySelector('#pfLabel');

  function updatePFLabel(){
    if (pfLabel) pfLabel.textContent = `${GLOBAL_PF_DEG|0}¬∞`;
  }

  function updateLabels(){
    if (!actionSel) return;
    const opt = actionSel.selectedOptions?.[0];
    labelTest.textContent = opt ? opt.textContent.trim() : '(none)';
    labelBucket.textContent = CURRENT_BODY_BUCKET || 'high';
    updatePFLabel();
  }


  // Helper: get or create override object for current test+bucket
  function getCurrentOverrideKey(){
    if (!CURRENT_BODY_TEST || !CURRENT_BODY_BUCKET) return null;
    return `${CURRENT_BODY_TEST}:${CURRENT_BODY_BUCKET}`;
  }

  function ensureOverrideFromCurrentPose(){
    const key = getCurrentOverrideKey();
    if (!key || !model) return null;
    if (!POSE_OVERRIDES[key]){
      const euler = new THREE.Euler().copy(model.rotation);
      POSE_OVERRIDES[key] = {
        x: model.position.x,
        y: model.position.y,
        z: model.position.z,
        rx: euler.x,
        ry: euler.y,
        rz: euler.z
      };
    }
    return key;
  }

  function applyOverride(key){
    const o = key && POSE_OVERRIDES[key];
    if (!o || !model) return;
    model.position.set(o.x, o.y, o.z);
    model.rotation.set(o.rx, o.ry, o.rz);
  }

  // Position buttons
  poseTunerEl.querySelectorAll('button[data-axis]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const key = ensureOverrideFromCurrentPose();
      if (!key) return;
      const axis = btn.getAttribute('data-axis');
      const delta = parseFloat(btn.getAttribute('data-delta') || '0');
      const o = POSE_OVERRIDES[key];
      if (axis === 'x') o.x += delta;
      if (axis === 'y') o.y += delta;
      if (axis === 'z') o.z += delta;
      applyOverride(key);
    });
  });

  // Rotation buttons (deg)
  poseTunerEl.querySelectorAll('button[data-rot]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const key = ensureOverrideFromCurrentPose();
      if (!key) return;
      const axis = btn.getAttribute('data-rot');
      const deltaDeg = parseFloat(btn.getAttribute('data-delta') || '0');
      const deltaRad = THREE.MathUtils.degToRad(deltaDeg);
      const o = POSE_OVERRIDES[key];
      if (axis === 'x') o.rx += deltaRad;
      if (axis === 'y') o.ry += deltaRad;
      if (axis === 'z') o.rz += deltaRad;
      applyOverride(key);
    });
  });
  // Plantarflexion buttons
  poseTunerEl.querySelectorAll('button[data-pf]').forEach(btn => {
    btn.addEventListener('click', () => {
      const delta = parseFloat(btn.getAttribute('data-pf') || '0');
      // Clamp so you don't break ankles
      GLOBAL_PF_DEG = Math.max(-40, Math.min(40, GLOBAL_PF_DEG + delta));
      applyGlobalPF();
      updatePFLabel();
    });
  });

  // Reset to base (throw away override & re-apply base mode)
  btnSnapBase.onclick = () => {
    const key = getCurrentOverrideKey();
    if (key && POSE_OVERRIDES[key]) delete POSE_OVERRIDES[key];
    applyBodyPositionFromSelection();
    updateLabels();
  };

  // Save button just logs config so you can later hard-code it if you want
  btnSave.onclick = () => {
    const key = ensureOverrideFromCurrentPose();
    if (!key) return;
    const o = POSE_OVERRIDES[key];
    console.log(`POSE_OVERRIDES["${key}"] = { x:${o.x.toFixed(3)}, y:${o.y.toFixed(3)}, z:${o.z.toFixed(3)}, rx:${o.rx.toFixed(3)}, ry:${o.ry.toFixed(3)}, rz:${o.rz.toFixed(3)} };`);
    labelTest.style.color = '#22c55e';
    setTimeout(()=>labelTest.style.color='#e2e8f0', 600);
  };

  // Close
  btnClose.onclick = () => {
    poseTunerVisible = false;
    poseTunerEl.style.display = 'none';
  };

  // Public helper so other code can refresh labels when test/grade changes
  poseTunerEl.updateLabels = updateLabels;

  return poseTunerEl;
}

function showPoseTuner(show){
  ensurePoseTuner();
  poseTunerVisible = (show === undefined) ? !poseTunerVisible : !!show;
  poseTunerEl.style.display = poseTunerVisible ? 'block' : 'none';
  if (poseTunerVisible && poseTunerEl.updateLabels) poseTunerEl.updateLabels();
}
// Init the Pose Tuner once the module + DOM are ready
window.addEventListener("load", () => {
  try {
    ensurePoseTuner();
    showPoseTuner(true); // dev: show on first load
  } catch (e) {
    const m = document.getElementById("msg");
    if (m) m.textContent = "‚ö†Ô∏è Pose tuner init failed: " + e.message;
    console.error(e);
  }
});
 
/* ==== Loop & resize ==== */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
(function loop(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
})();

</script>
</body>
</html>
