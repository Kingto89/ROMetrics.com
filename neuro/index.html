<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ROMetrics â€” Clinical Anatomy Viewer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root{ --bg:#0f172a; --panel:rgba(15, 23, 42, 0.95); --accent:#38bdf8; --text:#f1f5f9; --border:#334155; }
html,body{ margin:0;height:100%;overflow:hidden; background:var(--bg);color:var(--text); font-family:'Inter',sans-serif; }
canvas{ position:fixed;inset:0;width:100%;height:100%; outline:none; }

/* UI Panel */
#uiPanel{
  position:fixed; right:20px; top:20px; width:340px;
  background:var(--panel); border:1px solid var(--border);
  border-radius:12px; padding:20px;
  box-shadow:0 10px 40px rgba(0,0,0,0.6);
  max-height:90vh; overflow-y:auto;
  backdrop-filter: blur(10px);
}

h2 { margin:0 0 15px; font-size:18px; color:#fff; letter-spacing:-0.5px; }

/* Controls */
label { font-size:11px; font-weight:700; color:#94a3b8; display:block; margin-bottom:5px; text-transform:uppercase; letter-spacing:0.5px; }
select, input[type=range] {
  width:100%; padding:10px; border-radius:6px; margin-bottom:15px;
  background:#1e293b; color:#fff; border:1px solid var(--border); font-size:13px; outline:none;
}

/* Data Display */
.info-card { background:rgba(255,255,255,0.03); border-radius:8px; padding:15px; border:1px solid var(--border); margin-top:10px; }
.level-tag { font-size:24px; font-weight:800; letter-spacing:-1px; margin-bottom:5px; display:block; }
.section-title { font-size:11px; color:var(--accent); font-weight:700; text-transform:uppercase; margin-top:12px; display:block; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:2px; margin-bottom:4px; }
.data-text { font-size:13px; line-height:1.5; color:#cbd5e1; }
.muscle-list { margin:0; padding-left:16px; font-size:13px; color:#cbd5e1; }
.muscle-list li { margin-bottom:4px; }
</style>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>
</head>

<body>
<canvas id="c"></canvas>

<div id="uiPanel">
  <h2>Clinical Examiner</h2>
  
  <label>Map Layer</label>
  <select id="modeSel">
    <option value="derm">Dermatomes (Sensory)</option>
    <option value="myo">Myotomes (Motor)</option>
    <option value="none">None (Model Only)</option>
  </select>

  <label>Layer Opacity</label>
  <input id="opacitySel" type="range" min="0" max="1" step="0.05" value="0.85" />

  <div id="dataDisplay">
    <div style="padding:20px; text-align:center; color:#64748b; border:2px dashed #334155; border-radius:8px; font-size:13px;">
      Loading model & calculating map...
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
import {DRACOLoader} from 'three/addons/loaders/DRACOLoader.js';
import {KTX2Loader} from 'three/addons/loaders/KTX2Loader.js';

/* ------------------------------------------------------------------
   1. CLINICAL DATABASE
------------------------------------------------------------------ */
const DB = {
  "C2": { color:0xff0000, area:"Back of head, Upper neck", muscles:["Sternocleidomastoid"], action:"Neck Flexion/Rotation" },
  "C3": { color:0xff2a00, area:"Lower neck, Clavicle", muscles:["Trapezius"], action:"Neck Lateral Flexion" },
  "C4": { color:0xff5500, area:"Upper Shoulder/Scapula", muscles:["Levator Scapulae", "Diaphragm"], action:"Shoulder Elevation" },
  "C5": { color:0xff8000, area:"Lateral Upper Arm", muscles:["Deltoid", "Biceps"], action:"Shoulder Abduction" },
  "C6": { color:0xffaa00, area:"Thumb, Index Finger, Lat. Forearm", muscles:["Wrist Extensors", "Biceps"], action:"Wrist Extension" },
  "C7": { color:0xffff00, area:"Middle Finger, Palm", muscles:["Triceps", "Wrist Flexors"], action:"Elbow Extension" },
  "C8": { color:0xaaff00, area:"Pinky/Ring Finger", muscles:["Finger Flexors"], action:"Grip / Finger Flexion" },
  "T1": { color:0x55ff00, area:"Medial Arm / Axilla", muscles:["Interossei"], action:"Finger Abduction" },
  "T4": { color:0x00ff40, area:"Nipple Line / Chest", muscles:["Intercostals"], action:"Respiration" },
  "T10":{ color:0x00ff80, area:"Umbilicus / Mid-Back", muscles:["Abdominals"], action:"Core Stability" },
  "L1": { color:0x00ffff, area:"Groin / Upper Hip", muscles:["Iliopsoas"], action:"Hip Flexion (Minor)" },
  "L2": { color:0x00aaff, area:"Anterior Thigh (Upper)", muscles:["Iliopsoas", "Adductors"], action:"Hip Flexion/Adduction" },
  "L3": { color:0x0055ff, area:"Knee / Mid-Thigh", muscles:["Quadriceps"], action:"Knee Extension" },
  "L4": { color:0x0000ff, area:"Medial Shin / Ankle", muscles:["Tibialis Anterior"], action:"Ankle Dorsiflexion" },
  "L5": { color:0x5500ff, area:"Top of Foot / Big Toe", muscles:["Extensor Hallucis Longus"], action:"Great Toe Extension" },
  "S1": { color:0xaa00ff, area:"Lateral Foot / Sole / Calf", muscles:["Gastrocnemius", "Gluteus Max"], action:"Plantarflexion" },
  "S2": { color:0xff00ff, area:"Posterior Thigh Strip", muscles:["Hamstrings"], action:"Knee Flexion" },
  "S3": { color:0xff0088, area:"Buttocks (Sit bones)", muscles:["Pelvic Floor"], action:"Bowel/Bladder" }
};

// MAPPING: Bone Keywords -> Level
const BONE_MAP = [
    { k:["head","jaw"], v:"C2" }, { k:["neck"], v:"C3" },
    { k:["shoulder","clavicle"], v:"C4" }, { k:["arm","humerus"], v:"C5" },
    { k:["forearm","radius","ulna"], v:"C6" }, { k:["thumb","index"], v:"C6" },
    { k:["middle"], v:"C7" }, { k:["pinky","ring"], v:"C8" },
    { k:["spine2","chest"], v:"T4" }, { k:["spine1","abdomen"], v:"T10" },
    { k:["spine","pelvis"], v:"L1" }, { k:["upleg","thigh","femur"], v:"L2" },
    { k:["leg","shin","calf"], v:"L4" }, { k:["foot","ankle"], v:"L5" },
    { k:["toe","ball"], v:"S1" }
];

/* ------------------------------------------------------------------
   2. SCENE SETUP
------------------------------------------------------------------ */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f172a);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 1.5, 3);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

const amb = new THREE.AmbientLight(0xffffff, 1.2);
scene.add(amb);
const dir = new THREE.DirectionalLight(0xffffff, 2);
dir.position.set(5, 10, 7);
scene.add(dir);

/* ------------------------------------------------------------------
   3. LOADING & GENERATION
------------------------------------------------------------------ */
const loader = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
loader.setDRACOLoader(draco);

let regionMeshes = {};
let originalColors = {};

function getModelURL(){
  const u = new URL(location.href);
  const q = u.searchParams.get("model");
  return (q && /^https?:\/\//i.test(q)) ? q : "../assets/Roma_ROMetrics.glb";
}

loader.load(getModelURL(), (gltf) => {
    const model = gltf.scene;
    scene.add(model);

    // 1. Calculate Model Scale & Center
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    // 2. Fit Camera
    controls.target.copy(center);
    camera.position.copy(center);
    camera.position.z += maxDim * 2.0; 
    controls.update();

    // 3. Find Body Mesh
    let body = null;
    model.traverse(c => {
        if(c.isSkinnedMesh && c.skeleton && !body){
            if(c.geometry.attributes.position.count > 2000) body = c;
        }
    });

    if(body) {
        // Pass the maxDim to the generator so it knows how big to make the dots
        generateMaps(body, center, maxDim);
        document.getElementById('dataDisplay').innerHTML = `
            <div style="padding:15px; text-align:center; color:#fff; background:rgba(56, 189, 248, 0.1); border:1px solid #38bdf8; border-radius:8px;">
                Click a region on the model to view details.
            </div>`;
    } else {
        document.getElementById('dataDisplay').textContent = "Error: No rigged body mesh found.";
    }
});

function generateMaps(mesh, modelCenter, maxDimension){
    const pos = mesh.geometry.attributes.position;
    const skinIdx = mesh.geometry.attributes.skinIndex;
    const skinWt = mesh.geometry.attributes.skinWeight;
    const bones = mesh.skeleton.bones;
    
    const buckets = {}; 
    const tempPos = new THREE.Vector3();

    // **Dynamic Dot Size** (This fixes the visibility issue)
    const DOT_SIZE = maxDimension * 0.008; 

    for(let i=0; i<pos.count; i++){
        // Calculate World Position relative to Model Center
        tempPos.fromBufferAttribute(pos, i);
        tempPos.applyMatrix4(mesh.matrixWorld);
        
        const isRight = tempPos.x < modelCenter.x; 
        const isFront = tempPos.z > modelCenter.z; // Uses center to determine front/back

        // Identify Bone
        let maxW=0, bId=0;
        for(let k=0; k<4; k++){
            const w = skinWt.getComponent(i,k);
            if(w > maxW){ maxW=w; bId = skinIdx.getComponent(i,k); }
        }
        const bName = bones[bId].name.toLowerCase();

        // Logic
        let level = null;
        if(bName.includes("hip") || bName.includes("pelvis")){
            level = isFront ? "L1" : "S3"; 
        } else if(bName.includes("upleg") || bName.includes("thigh")){
            level = isFront ? "L2" : "S2"; 
        } else {
            for(const m of BONE_MAP){
                if(m.k.some(kw => bName.includes(kw))){ level = m.v; break; }
            }
        }

        if(level){
            const key = `${level}-${isRight?'R':'L'}`;
            if(!buckets[key]) buckets[key] = [];
            buckets[key].push(i);
        }
    }

    // Build Meshes
    const worldPosArr = [];
    for(let i=0; i<pos.count; i++){
        tempPos.fromBufferAttribute(pos, i);
        tempPos.applyMatrix4(mesh.matrixWorld);
        worldPosArr.push(tempPos.clone());
    }

    for(const [key, indices] of Object.entries(buckets)){
        const level = key.split('-')[0];
        const data = DB[level];
        if(!data) continue;

        const geo = new THREE.BufferGeometry();
        const verts = [];
        indices.forEach(idx => {
            const p = worldPosArr[idx];
            verts.push(p.x, p.y, p.z);
        });
        geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));

        const mat = new THREE.PointsMaterial({
            color: data.color,
            size: DOT_SIZE,      // Used the dynamic size here
            transparent: true,
            opacity: 0.85,
            depthTest: false,    // Forces dots on top of skin
            depthWrite: false,
            sizeAttenuation: true
        });

        const points = new THREE.Points(geo, mat);
        points.renderOrder = 999; // Draws last (on top)
        points.userData = { id: key, level: level, ...data };
        
        scene.add(points);
        regionMeshes[key] = points;
        originalColors[key] = data.color;
    }
}

/* ------------------------------------------------------------------
   4. INTERACTION
------------------------------------------------------------------ */
const raycaster = new THREE.Raycaster();
raycaster.params.Points.threshold = 0.05; 
const mouse = new THREE.Vector2();
const ui = document.getElementById('dataDisplay');
let hoveredObj = null;

function onMove(e){
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    
    const visible = Object.values(regionMeshes).filter(m=>m.visible);
    if(!visible.length) return;

    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(visible, false);

    if(hits.length > 0){
        const hit = hits[0].object;
        if(hoveredObj !== hit){
            if(hoveredObj) hoveredObj.material.color.setHex(originalColors[hoveredObj.userData.id]);
            hoveredObj = hit;
            hoveredObj.material.color.setHex(0xffffff); 
            document.body.style.cursor = "pointer";
        }
    } else {
        if(hoveredObj){
            hoveredObj.material.color.setHex(originalColors[hoveredObj.userData.id]);
            hoveredObj = null;
            document.body.style.cursor = "default";
        }
    }
}

function onClick(){
    if(hoveredObj){
        updatePanel(hoveredObj.userData);
    }
}

function updatePanel(data){
    const mode = document.getElementById('modeSel').value;
    const side = data.id.includes("-R") ? "Right" : "Left";
    const hex = '#'+data.color.toString(16).padStart(6,'0');

    let content = `
        <div class="info-card">
            <span class="level-tag" style="color:${hex}">${data.level} <span style="font-size:14px;opacity:0.7">(${side})</span></span>
    `;

    if(mode === 'derm'){
        content += `
            <span class="section-title">Sensory Distribution</span>
            <div class="data-text">${data.area}</div>
        `;
    } else if(mode === 'myo'){
        if(data.muscles){
            content += `
                <span class="section-title">Key Muscles (Motor)</span>
                <ul class="muscle-list">
                    ${data.muscles.map(m => `<li>${m}</li>`).join('')}
                </ul>
                <span class="section-title">Primary Action</span>
                <div class="data-text" style="color:#fff;font-weight:500">${data.action}</div>
            `;
        } else {
            content += `<div class="data-text" style="margin-top:10px">Primarily sensory at this level.</div>`;
        }
    }
    content += `</div>`;
    ui.innerHTML = content;
}

window.addEventListener('mousemove', onMove);
window.addEventListener('click', onClick);

// Visibility Logic
const modeSel = document.getElementById('modeSel');
const opSel = document.getElementById('opacitySel');

function updateVis(){
    const mode = modeSel.value;
    const op = parseFloat(opSel.value);
    
    for(const m of Object.values(regionMeshes)){
        m.material.opacity = op;
        if(mode === 'none'){
            m.visible = false;
        } else if(mode === 'derm'){
            m.visible = true; 
        } else if(mode === 'myo'){
            if(m.userData.muscles) m.visible = true;
            else m.visible = false;
        }
    }
}

modeSel.addEventListener('change', updateVis);
opSel.addEventListener('input', updateVis);

function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
