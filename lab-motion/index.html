<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ROMetrics â€” Motion Lab (Fixed)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{--bg:#0b1220;--panel:#0f172a;--line:#1f2937;--ctrl:#1e293b;--text:#e2e8f0;--muted:#cbd5e1}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
.panel{position:fixed;left:12px;top:12px;width:360px;max-height:90vh;z-index:20;background:var(--panel);border:1px solid var(--line);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.4);display:flex;flex-direction:column;overflow:hidden}
.dragbar{cursor:move;background:#0c1628;border-bottom:1px solid #162235;padding:8px 12px;font-weight:700;display:flex;align-items:center;gap:8px}
.dragbar .hint{margin-left:auto;font-size:12px;color:#9fb0c9}
.content{padding:12px;overflow:auto}
label{display:block;font-size:12px;margin-top:8px;color:var(--muted)}
select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:var(--ctrl);border:1px solid #334155;color:#e2e8f0}
.row{display:flex;gap:8px}.row>button{flex:1}
.mini{padding:6px 10px;border-radius:8px;background:var(--ctrl);border:1px solid #334155}
optgroup{color:#9fb0c9;font-style:normal}
#log{background:#0b1220;border:1px solid #1f2937;min-height:80px;max-height:130px;overflow:auto;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
#msg{position:fixed;bottom:10px;left:12px;background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:12px;z-index:25}
</style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="dragbar" id="dragbar">ðŸ§­ Motion Lab <span class="hint">drag</span></div>
    <div class="content">
      <div class="row" style="align-items:center">
        <label style="display:flex;gap:6px;align-items:center;margin:0;">
          <input id="antiBox" type="checkbox"/>
          <span>Anticollision</span>
        </label>
        <button id="zeroAll" class="mini">Zero All</button>
      </div>

      <label>Body Region</label>
      <div class="row">
        <button id="segUpper" class="mini" style="flex:1;background:#1b2741">Upper</button>
        <button id="segLower" class="mini" style="flex:1">Lower</button>
      </div>

      <label>Action</label>
      <select id="actionSel"></select>

      <label><span id="pairLabel">Angle (Â°)</span></label>
      <input type="range" id="actionDeg" min="0" max="180" step="1" value="0"/>

      <label>Event Log</label>
      <pre id="log"></pre>
    </div>
  </div>

  <div id="msg">Loadingâ€¦</div>
  <canvas id="c"></canvas>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

// ---------- UI helpers ----------
const msg = document.getElementById("msg");
const logEl = document.getElementById("log");
const log = (t)=>{ logEl.textContent += t + "\\n"; logEl.scrollTop = logEl.scrollHeight; };

// drag panel
(function(){
  const panel = document.getElementById("panel");
  const bar = document.getElementById("dragbar");
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  bar.addEventListener("pointerdown",(e)=>{ dragging=true; sx=e.clientX; sy=e.clientY; const r=panel.getBoundingClientRect(); startLeft=r.left; startTop=r.top;});
  addEventListener("pointermove",(e)=>{ if(!dragging) return; panel.style.left = Math.max(8, startLeft + (e.clientX-sx)) + "px"; panel.style.top = Math.max(8, startTop + (e.clientY-sy)) + "px"; });
  addEventListener("pointerup",()=> dragging=false);
})();

// ---------- Three.js scene ----------
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1220);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(1.6, 1.6, 3.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.minDistance = 0.6; controls.maxDistance = 6;
controls.target.set(0,1.1,0);

scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.7));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(2.5,4,2.5);
key.castShadow = true;
key.shadow.mapSize.set(2048,2048);
key.shadow.camera.near = 0.1; key.shadow.camera.far = 15;
key.shadow.camera.left = -4; key.shadow.camera.right = 4; key.shadow.camera.top = 4; key.shadow.camera.bottom = -4;
scene.add(key);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.ShadowMaterial({ opacity: 0.45 }));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

// ---------- Load model ----------
const loader = new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

let model=null, skeleton=null;
const initialQ = new Map();

function pickModelUrl(){
  const u = new URL(location.href);
  const q = u.searchParams.get("model");
  if (q && /^https?:\\/\\//i.test(q)) return q;
  if (q && q.trim()) return new URL(q, location.href).href;
  return "./Athletic_Grace_1006002620_texture.glb";
}
let MODEL_URL = pickModelUrl();

function groundSnap(){
  if (!model) return;
  const box = new THREE.Box3().setFromObject(model);
  const minY = box.min.y;
  if (isFinite(minY)) model.position.y -= minY;
}

function clearModel(){
  if (model) scene.remove(model);
  model=null; skeleton=null; initialQ.clear();
}

function loadModel(){
  msg.textContent = "Loadingâ€¦"; log("Loading modelâ€¦");
  clearModel();
  loader.load(MODEL_URL,(gltf)=>{
    model = gltf.scene;
    model.traverse(o=>{
      if (o.isMesh){ o.castShadow=true; o.receiveShadow=true; }
      if (o.isSkinnedMesh && !skeleton) skeleton = o.skeleton;
    });
    scene.add(model); groundSnap();
    // cache base quaternions
    skeleton?.bones.forEach(b=> initialQ.set(b, b.quaternion.clone()));
    log("âœ… Model loaded");
    initAfterLoad();
  },
  (xhr)=>{ const pct = xhr.lengthComputable ? Math.min(100, Math.round((xhr.loaded/xhr.total)*100)) : null; msg.textContent = (pct!==null?`Loading ${pct}%`:"Loadingâ€¦"); },
  (err)=>{ console.error(err); msg.textContent = "âš ï¸ Load error"; log("Error: " + (err?.message||err)); });
}
loadModel();

// ---------- Bone helpers ----------
function qBase(b){ return initialQ.get(b) || b.quaternion.clone(); }
function getBone(name){ if (!skeleton) return null; const L = name.toLowerCase(); return skeleton.bones.find(b => (b.name||"").toLowerCase()===L) || null; }
function find(side, reList){
  if (!skeleton) return null;
  const rSide = side==='l' ? [/\\bleft\\b/i,/\\.l\\b/i,/\\b_l\\b/i,/\\bl\\b(?![a-z])/i] : [/\\bright\\b/i,/\\.r\\b/i,/\\b_r\\b/i,/\\br\\b(?![a-z])/i];
  for (const r of reList){
    const hit = skeleton.bones.find(b=> r.test((b.name||"")) && rSide.some(s=>s.test((b.name||""))));
    if (hit) return hit;
  }
  return null;
}

// preferred bindings
const BIND_HINTS = {
  sh: [/upperarm|humerus|shoulder|arm(?!.*lower)/i],
  sc: [/scapula|clavicle/i],
  el: [/lowerarm|forearm|ulna|radius/i],
  wr: [/hand|wrist(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i],
  trunk: [/^spine01$/i],
  cerv: [/^neck$|head|cspine/i]
};

function resolveShoulder(side){
  return getBone(side==='l'?'upperarm_L':'upperarm_R') || find(side, BIND_HINTS.sh) ;
}
function resolveScapula(side){
  return getBone(side==='l'?'clavicle_L':'clavicle_R') || find(side, BIND_HINTS.sc);
}
function resolveElbow(side){
  return getBone(side==='l'?'lowerarm_L':'lowerarm_R') || find(side, BIND_HINTS.el);
}
function resolveWrist(side){
  return getBone(side==='l'?'hand_L':'hand_R') || find(side, BIND_HINTS.wr);
}
function resolveTrunk(){ return getBone('spine01') || (skeleton?.bones.find(b=>BIND_HINTS.trunk[0].test(b.name))||null); }
function resolveNeck(){ return getBone('neck') || (skeleton?.bones.find(b=>/neck|cspine/i.test(b.name))||null); }

// axis map (Mixamo-friendly defaults)
const AXIS = {
  sh_fe: 'x',     // flex/ext
  sh_aa: 'z',     // abd/add
  sh_irer: 'y',   // IR/ER
  el_fe: 'x',
  wr_fe: 'x',
  wr_ru: 'z',
  wr_ps: 'y',
  trunk_fe:'x',
  trunk_lat:'z',
  trunk_rot:'y',
  cerv_fe:'x',
  cerv_lat:'z',
  cerv_rot:'y'
};

// safe ROM caps
const COLLIM = {
  enabled: true,
  shFlexLMax: 170, shFlexRMax: 170,
  shAbdLMax: 190,  shAbdRMax: 190,  // +10Â° headroom per request
  shExtLMax: 60,   shExtRMax: 60,
  shAddLMax: 30,   shAddRMax: 30,
  cervRotLMax: 80, cervRotRMax: 80
};

// coupling only for ABDUCTION
const ABD_KICK = {
  erMax: 45,          // up to 45Â° ER during abduction
  erRampEnd: 120,     // reach full ER by ~120Â° abd
  scapScale: 0.50     // clavicle/scap upward rotation ~0.5x humeral abd
};

// minimal state
const antiBox = document.getElementById('antiBox');
antiBox.checked = true;
antiBox.addEventListener('input', ()=>{ COLLIM.enabled = !!antiBox.checked; log(`Anticollision ${COLLIM.enabled?'ON':'OFF'}`); });

// Actions catalog
const actionSel = document.getElementById("actionSel");
const actionDeg = document.getElementById("actionDeg");
const pairLabel = document.getElementById("pairLabel");
const segUpper = document.getElementById("segUpper");
const segLower = document.getElementById("segLower");
const zeroAll = document.getElementById("zeroAll");

const UPPER = [
  {key:'trunk_fe',  label:'Trunk â€” Flexion',  side:'' , axis:AXIS.trunk_fe, min:0, max:60,   bind:resolveTrunk},
  {key:'trunk_ext', label:'Trunk â€” Extension',side:'' , axis:AXIS.trunk_fe, min:0, max:80,   bind:resolveTrunk, sign:-1},

  {key:'cerv_fe',   label:'Cervical â€” Flexion',  side:'' , axis:AXIS.cerv_fe, min:0, max:60, bind:resolveNeck},
  {key:'cerv_ext',  label:'Cervical â€” Extension',side:'' , axis:AXIS.cerv_fe, min:0, max:70, bind:resolveNeck, sign:-1},
  {key:'cerv_lat_l',label:'Cervical â€” Lateral Flex L', side:'' , axis:AXIS.cerv_lat, min:0, max:45, bind:resolveNeck, sign:-1},
  {key:'cerv_lat_r',label:'Cervical â€” Lateral Flex R', side:'' , axis:AXIS.cerv_lat, min:0, max:45, bind:resolveNeck, sign:+1},
  {key:'cerv_rot_l',label:'Cervical â€” Rotation L', side:'' , axis:AXIS.cerv_rot, min:0, max:80, bind:resolveNeck, sign:+1},
  {key:'cerv_rot_r',label:'Cervical â€” Rotation R', side:'' , axis:AXIS.cerv_rot, min:0, max:80, bind:resolveNeck, sign:-1},

  // SHOULDER â€” keep flexion (sagittal) clean; apply coupling only to abduction
  {key:'sh_fe_l',   label:'Shoulder L â€” Flexion',  side:'l', axis:AXIS.sh_fe, min:0, max:COLLIM.shFlexLMax, bind:()=>resolveShoulder('l'), sign:+1},
  {key:'sh_ext_l',  label:'Shoulder L â€” Extension',side:'l', axis:AXIS.sh_fe, min:0, max:COLLIM.shExtLMax,  bind:()=>resolveShoulder('l'), sign:-1},
  {key:'sh_fe_r',   label:'Shoulder R â€” Flexion',  side:'r', axis:AXIS.sh_fe, min:0, max:COLLIM.shFlexRMax, bind:()=>resolveShoulder('r'), sign:+1},
  {key:'sh_ext_r',  label:'Shoulder R â€” Extension',side:'r', axis:AXIS.sh_fe, min:0, max:COLLIM.shExtRMax,  bind:()=>resolveShoulder('r'), sign:-1},

  {key:'sh_abd_l',  label:'Shoulder L â€” Abduction', side:'l', axis:AXIS.sh_aa, min:0, max:COLLIM.shAbdLMax, bind:()=>resolveShoulder('l'), sign:+1},
  {key:'sh_add_l',  label:'Shoulder L â€” Adduction', side:'l', axis:AXIS.sh_aa, min:0, max:COLLIM.shAddLMax, bind:()=>resolveShoulder('l'), sign:-1},
  {key:'sh_abd_r',  label:'Shoulder R â€” Abduction', side:'r', axis:AXIS.sh_aa, min:0, max:COLLIM.shAbdRMax, bind:()=>resolveShoulder('r'), sign:+1},
  {key:'sh_add_r',  label:'Shoulder R â€” Adduction', side:'r', axis:AXIS.sh_aa, min:0, max:COLLIM.shAddRMax, bind:()=>resolveShoulder('r'), sign:-1},

  {key:'sh_ir_l',   label:'Shoulder L â€” Internal Rotation (elbow 90Â°)', side:'l', axis:AXIS.sh_irer, min:0, max:90,  bind:()=>resolveShoulder('l'), sign:+1},
  {key:'sh_er_l',   label:'Shoulder L â€” External Rotation (elbow 90Â°)', side:'l', axis:AXIS.sh_irer, min:0, max:90,  bind:()=>resolveShoulder('l'), sign:-1},
  {key:'sh_ir_r',   label:'Shoulder R â€” Internal Rotation (elbow 90Â°)', side:'r', axis:AXIS.sh_irer, min:0, max:90,  bind:()=>resolveShoulder('r'), sign:+1},
  {key:'sh_er_r',   label:'Shoulder R â€” External Rotation (elbow 90Â°)', side:'r', axis:AXIS.sh_irer, min:0, max:90,  bind:()=>resolveShoulder('r'), sign:-1}
];

const LOWER = [
  {key:'hip_fe_l', label:'Hip L â€” Flexion', side:'l', axis:'x', min:0, max:120, bind:()=>getBone('thigh_L'), sign:+1},
  {key:'hip_ext_l',label:'Hip L â€” Extension',side:'l', axis:'x', min:0, max:30,  bind:()=>getBone('thigh_L'), sign:-1},
  {key:'hip_fe_r', label:'Hip R â€” Flexion', side:'r', axis:'x', min:0, max:120, bind:()=>getBone('thigh_R'), sign:+1},
  {key:'hip_ext_r',label:'Hip R â€” Extension',side:'r', axis:'x', min:0, max:30,  bind:()=>getBone('thigh_R'), sign:-1},

  {key:'knee_fe_l',label:'Knee L â€” Flexion', side:'l', axis:'x', min:0, max:150, bind:()=>getBone('calf_L'), sign:+1},
  {key:'knee_ext_l',label:'Knee L â€” Extension',side:'l', axis:'x', min:0, max:5, bind:()=>getBone('calf_L'), sign:-1},
  {key:'knee_fe_r',label:'Knee R â€” Flexion', side:'r', axis:'x', min:0, max:150, bind:()=>getBone('calf_R'), sign:+1},
  {key:'knee_ext_r',label:'Knee R â€” Extension',side:'r', axis:'x', min:0, max:5, bind:()=>getBone('calf_R'), sign:-1}
];

let CURRENT = UPPER;
function fillMenu(){
  actionSel.innerHTML = "";
  const ph = document.createElement("option"); ph.value=""; ph.textContent="(Select motionâ€¦)"; actionSel.appendChild(ph);
  CURRENT.forEach((a,i)=>{ const o=document.createElement("option"); o.value=String(i); o.textContent=a.label; actionSel.appendChild(o); });
  actionSel.value="";
  actionDeg.disabled = true; actionDeg.value = "0"; pairLabel.textContent = "Angle (Â°)";
}
fillMenu();

segUpper.onclick = ()=>{ CURRENT=UPPER; segUpper.style.background="#1b2741"; segLower.style.background=""; fillMenu(); };
segLower.onclick = ()=>{ CURRENT=LOWER; segLower.style.background="#1b2741"; segUpper.style.background=""; fillMenu(); };

let CURRENT_ACTION = null;

actionSel.addEventListener("change", ()=>{
  CURRENT_ACTION = null;
  resetAll();
  const idx = parseInt(actionSel.value||"-1",10);
  if (isNaN(idx) || !CURRENT[idx]){ actionDeg.disabled=true; pairLabel.textContent = "Angle (Â°)"; return; }
  CURRENT_ACTION = CURRENT[idx];
  actionDeg.min = "0"; actionDeg.max = String(CURRENT_ACTION.max); actionDeg.value = "0"; actionDeg.disabled=false;
  pairLabel.textContent = `${CURRENT_ACTION.label} â€” Angle (Â°)`;
  // special prep for shoulder IR/ER â†’ set elbow ~90Â° (visual realism)
  if (/^sh_(ir|er)_/.test(CURRENT_ACTION.key)){
    // try to flex elbow a bit visually (optional minimal)
    const side = CURRENT_ACTION.side;
    const ulna = resolveElbow(side);
    if (ulna){
      const qb = qBase(ulna).clone();
      const e = new THREE.Euler(THREE.MathUtils.degToRad(90),0,0,"XYZ");
      ulna.quaternion.copy(qb).multiply(new THREE.Quaternion().setFromEuler(e));
      log(`Elbow ${side.toUpperCase()} preset to 90Â° for IR/ER.`);
    }
  }
});

function capFor(a, val){
  if (!COLLIM.enabled) return val;
  if (!a) return val;
  // per-action caps
  if (/^sh_fe_/.test(a.key)) return Math.min(val, a.side==='l'?COLLIM.shFlexLMax:COLLIM.shFlexRMax);
  if (/^sh_ext_/.test(a.key)) return Math.min(val, a.side==='l'?COLLIM.shExtLMax:COLLIM.shExtRMax);
  if (/^sh_abd_/.test(a.key)) return Math.min(val, a.side==='l'?COLLIM.shAbdLMax:COLLIM.shAbdRMax);
  if (/^sh_add_/.test(a.key)) return Math.min(val, a.side==='l'?COLLIM.shAddLMax:COLLIM.shAddRMax);
  if (a.key==='cerv_rot_l') return Math.min(val, COLLIM.cervRotLMax);
  if (a.key==='cerv_rot_r') return Math.min(val, COLLIM.cervRotRMax);
  return val;
}

function applyAxis(bone, axis, deg){
  if (!bone) return;
  const q0 = qBase(bone);
  const rad = THREE.MathUtils.degToRad(deg);
  const e = axis==='x' ? new THREE.Euler(rad,0,0,"XYZ")
        : axis==='y' ? new THREE.Euler(0,rad,0,"XYZ")
                      : new THREE.Euler(0,0,rad,"XYZ");
  bone.quaternion.copy(q0).multiply(new THREE.Quaternion().setFromEuler(e));
}

// helper to apply shoulder pair
function setShoulder(side, kind, deg){ // kind: 'fe' | 'aa' | 'irer'
  const hum = resolveShoulder(side); if (!hum) return;
  const axis = (kind==='fe')?AXIS.sh_fe:(kind==='aa')?AXIS.sh_aa:AXIS.sh_irer;
  applyAxis(hum, axis, deg);
}
function setScapula(side, deg){ // upward rotation via clavicle/scapula proxy
  const sc = resolveScapula(side); if (!sc) return;
  applyAxis(sc, 'z', deg); // use Z as upward rotation proxy
}

// FLEXION: keep clean (sagittal), NO auto-ABD or ER
function onFlex(side, deg, sign){
  setShoulder(side,'fe', sign*deg);
}

// ABDUCTION: apply coupling â€” ER ramp + scap upward rotation
function onAbd(side, deg, sign){
  const amount = sign*deg; // sign +1 for abd
  setShoulder(side,'aa', amount);

  // ER coupling ramp to ~45Â° by 120Â° abduction
  const er = Math.min(ABD_KICK.erMax, (deg/ABD_KICK.erRampEnd)*ABD_KICK.erMax);
  setShoulder(side,'irer', -er); // negative â†’ ER in our map

  // scapulothoracic/clavicle contribution
  setScapula(side, deg * ABD_KICK.scapScale);
}

// IR/ER: simple
function onRot(side, isIR, deg){
  setShoulder(side,'irer', isIR ? +deg : -deg);
}

actionDeg.addEventListener("input", ()=>{
  if (!CURRENT_ACTION) return;
  let v = parseFloat(actionDeg.value)||0;
  v = Math.max(0, Math.min(CURRENT_ACTION.max, v));
  v = capFor(CURRENT_ACTION, v);
  actionDeg.value = String(v);

  const a = CURRENT_ACTION;
  const side = a.side;

  if (/^sh_fe_/.test(a.key))  return onFlex(side, v, a.sign||+1);
  if (/^sh_ext_/.test(a.key)) return onFlex(side, v, a.sign||-1);
  if (/^sh_abd_/.test(a.key)) return onAbd(side, v, a.sign||+1);
  if (/^sh_add_/.test(a.key)) return onAbd(side, v, a.sign||-1);
  if (a.key==='sh_ir_l') return onRot('l', true, v);
  if (a.key==='sh_er_l') return onRot('l', false, v);
  if (a.key==='sh_ir_r') return onRot('r', true, v);
  if (a.key==='sh_er_r') return onRot('r', false, v);

  // Trunk & Cervical
  if (a.key.startsWith('trunk_')){
    const b = resolveTrunk(); if (!b) return;
    const axis = a.key==='trunk_fe' ? AXIS.trunk_fe :
                 a.key==='trunk_ext'? AXIS.trunk_fe :
                 a.key==='trunk_lat'? AXIS.trunk_lat : AXIS.trunk_rot;
    const signed = (a.sign||+1) * v;
    applyAxis(b, axis, signed);
    return;
  }
  if (a.key.startsWith('cerv_')){
    const b = resolveNeck(); if (!b) return;
    const axis = /_fe$/.test(a.key) ? AXIS.cerv_fe : /_lat_/.test(a.key) ? AXIS.cerv_lat : AXIS.cerv_rot;
    const signed = (a.sign||+1) * v;
    applyAxis(b, axis, signed);
    return;
  }

  // Lower body (simple)
  if (a.key.startsWith('hip_')){
    const b = a.side==='l' ? getBone('thigh_L') : getBone('thigh_R'); if (!b) return;
    applyAxis(b, 'x', (a.sign||+1)*v); return;
  }
  if (a.key.startsWith('knee_')){
    const b = a.side==='l' ? getBone('calf_L') : getBone('calf_R'); if (!b) return;
    applyAxis(b, 'x', (a.sign||+1)*v); return;
  }
});

function resetAll(){
  if (!skeleton) return;
  skeleton.bones.forEach(b=>{ const q0 = initialQ.get(b); if (q0) b.quaternion.copy(q0); });
  actionDeg.value="0"; pairLabel.textContent="Angle (Â°)";
}
document.getElementById("zeroAll").onclick = ()=>{ resetAll(); log("All bones reset to anatomic baseline."); };

function initAfterLoad(){
  // default UI
  document.getElementById("segUpper").click();
  // enable anticollision by default
  COLLIM.enabled = true; antiBox.checked = true;
  msg.textContent = "Ready";
  log("Anticollision ON. Flexion clean; Abduction couples ER(+scap). Max Abd = 190Â°, ER ramp to 45Â° by 120Â°.");
}

// resize
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

(function animate(){
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>

