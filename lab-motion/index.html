<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Motion Lab â€” Joint Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{--bg:#0b1220;--panel:#0f172a;--line:#1f2937;--ctrl:#1e293b;--text:#e2e8f0;--muted:#cbd5e1}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
.panel{position:fixed;left:12px;top:12px;width:360px;max-height:90vh;z-index:20;background:var(--panel);border:1px solid var(--line);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.4);display:flex;flex-direction:column;overflow:hidden}
.dragbar{cursor:move;background:#0c1628;border-bottom:1px solid #162235;padding:8px 12px;font-weight:700;display:flex;align-items:center;gap:8px}
.dragbar .hint{margin-left:auto;font-size:12px;color:#9fb0c9}
.content{padding:12px;overflow:auto}
label{display:block;font-size:12px;margin-top:8px;color:var(--muted)}
select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:var(--ctrl);border:1px solid #334155;color:#e2e8f0}
.row{display:flex;gap:8px}.row>button{flex:1}
.mini{padding:6px 10px;border-radius:8px;background:var(--ctrl);border:1px solid #334155}
.seg{display:flex;gap:8px}
.seg button{flex:1;padding:8px 10px;border-radius:10px;background:#142033;border:1px solid #334155;color:#cbd5e1}
.seg button.on{background:#1f2c43;color:#fff;border-color:#47618e}
details{border:1px solid #162235;border-radius:10px;padding:8px;background:#0b1426;margin-top:8px}
summary{cursor:pointer;font-weight:600;color:#dbe7ff}
#log{background:#0b1220;border:1px solid #1f2937;min-height:90px;max-height:130px;overflow:auto;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
#msg{position:fixed;bottom:10px;left:12px;background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:12px;z-index:25}
optgroup{color:#9fb0c9;font-style:normal}
.modal{position:fixed;right:16px;bottom:16px;width:min(420px,50vw);max-height:78vh;z-index:30;background:rgba(8,13,26,.96);border:1px solid #334155;border-radius:12px;backdrop-filter:blur(6px);display:none;flex-direction:column;overflow:hidden}
.modal.on{display:flex}
.modal .top{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #1f2a40;background:#0c1628}
.modal .top h4{margin:0;font-size:14px}
.modal .x{margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:18px;cursor:pointer}
.modal .body{padding:12px;overflow:auto}
.rom-item{border:1px solid #2a3a55;border-radius:10px;background:#101a2e;margin:8px 0;}
.rom-item summary{padding:10px 12px;list-style:none;cursor:pointer}
.rom-item summary::-webkit-details-marker{display:none}
.rom-item .inner{padding:8px 12px;border-top:1px solid #1c2941}
.rom-row{display:flex;gap:10px;font-size:13px;padding:4px 0}
.rom-head{width:160px;color:#9fb0c9}
.badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid #2a3a55;background:#132038;color:#cbd5e1;font-size:11px;margin-left:6px}
</style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="dragbar" id="dragbar">ðŸ§­ Joint Lab <span class="hint">drag me</span></div>
    <div class="content">
      <div class="row">
        <button id="reload" class="mini">Reload Model</button>
        <button id="romBtn" class="mini">ðŸ“˜ ROM Reference</button>
        <button id="btnAnatomic" class="mini" title="Shift+Click to reveal dev tuner">Anatomic Position</button>
      </div>

      <label>Body Region</label>
      <div class="seg">
        <button id="segUpper" class="on">Upper Body</button>
        <button id="segLower">Lower Body</button>
      </div>

      <label>Action </label>
      <select id="actionSel"></select>

      <label><span id="pairLabel">Angle (Â°)</span></label>
      <input type="range" id="actionDeg" min="-90" max="150" step="1" value="0">
      <div class="row" style="align-items:center">
  <button id="zeroAction" class="mini">Zero Current</button>
  <button id="zeroAll" class="mini" title="Reset everything to anatomic baseline">Zero All</button>
  <label style="display:flex;gap:6px;align-items:center;margin:0;">
    <input id="antiBox" type="checkbox" />
    <span title="Shift+Click to open developer tuner">Anticollision</span>
  </label>
</div>

      <details>
        <summary>Bone (Advanced)</summary>
        <label>Bone (Blender order)</label>
        <select id="boneSel"></select>
        <div class="row">
          <div style="flex:1">
            <label>Rotate X (Â°)</label>
            <input type="range" min="-180" max="180" step="1" value="0" id="rx">
          </div>
          <div style="flex:1">
            <label>Rotate Y (Â°)</label>
            <input type="range" min="-180" max="180" step="1" value="0" id="ry">
          </div>
        </div>
        <label>Rotate Z (Â°)</label>
        <input type="range" min="-180" max="180" step="1" value="0" id="rz">
        <div class="row"><button id="zeroBone" class="mini">Zero Bone</button></div>
      </details>

      <details>
        <summary>Model </summary>
        <div class="row">
          <div style="flex:1">
            <label>Model X (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0" id="mx">
          </div>
          <div style="flex:1">
            <label>Model Z (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0.6" id="mz">
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Model Y (m)</label>
            <input type="range" min="-0.2" max="0.6" step="0.005" value="0" id="my">
          </div>
          <div style="flex:1">
            <label>Scale (%)</label>
            <input type="range" min="40" max="200" step="1" value="125" id="ms">
          </div>
        </div>
        <label>Yaw (Â°)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="myaw">
        <div class="row"><button id="resetModel" class="mini">Reset Model</button></div>
      </details>

      <label>Event Log</label>
      <pre id="log"></pre>
    </div>
  </div>

  <div class="modal" id="romModal" aria-modal="true" role="dialog">
    <div class="top">
      <h4>ROM Reference</h4>
      <button class="x" id="romClose" aria-label="Close">âœ•</button>
    </div>
    <div class="body" id="romBody">
      <div class="rom-item"><summary>Shoulder</summary><div class="inner">Flex 0â€“180Â°, Ext 0â€“60Â°, Abd 0â€“180Â°, ER 0â€“90Â°, IR 0â€“70Â°</div></div>
      <div class="rom-item"><summary>Elbow</summary><div class="inner">Flex 0â€“150Â°, Ext 0â€“10Â°</div></div>
      <div class="rom-item"><summary>Forearm</summary><div class="inner">Sup 0â€“95Â°, Pro 0â€“85Â°</div></div>
      <div class="rom-item"><summary>Wrist</summary><div class="inner">Flex 0â€“80Â°, Ext 0â€“70Â°, UD 0â€“40Â°, RD 0â€“20Â°</div></div>
      <div class="rom-item"><summary>Hip</summary><div class="inner">Flex 0â€“120Â°, Ext 0â€“30Â°, Abd 0â€“45Â°, Add 0â€“30Â°</div></div>
      <div class="rom-item"><summary>Knee</summary><div class="inner">Flex 0â€“150Â°, Ext 0â€“5Â°</div></div>
      <div class="rom-item"><summary>Ankle/Foot</summary><div class="inner">DF 0â€“20Â°, PF 0â€“50Â°, Inv 0â€“35Â°, Ev 0â€“20Â°</div></div>
      <div class="rom-item"><summary>Trunk/Cervical</summary><div class="inner">Flex/Ext, Lat Flex L/R, Rotation L/R (norms per course)</div></div>
    </div>
  </div>

  <div id="msg">Loadingâ€¦</div>
  <canvas id="c"></canvas>

  <script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
  import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

  /* ===== UI ===== */
  const msg = document.getElementById("msg");
  const logEl = document.getElementById("log");
  const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  const panel = document.getElementById("panel");
  const dragbar = document.getElementById("dragbar");
  const reloadBtn = document.getElementById("reload");
  const romBtn = document.getElementById("romBtn");
  const romModal = document.getElementById("romModal");
  const romBody = document.getElementById("romBody");
  const romClose = document.getElementById("romClose");

  const segUpper = document.getElementById("segUpper");
  const segLower = document.getElementById("segLower");

  const actionSel = document.getElementById("actionSel");
  const actionDeg = document.getElementById("actionDeg");
  const pairLabel = document.getElementById("pairLabel");
  const zeroAction = document.getElementById("zeroAction");
  const zeroAll = document.getElementById("zeroAll");


  const boneSel = document.getElementById("boneSel");
  const rx = document.getElementById("rx");
  const ry = document.getElementById("ry");
  const rz = document.getElementById("rz");
  const zeroBone = document.getElementById("zeroBone");

  const mx = document.getElementById("mx");
  const my = document.getElementById("my");
  const mz = document.getElementById("mz");
  const ms = document.getElementById("ms");
  const myaw = document.getElementById("myaw");
  const resetModel = document.getElementById("resetModel");

  const btnAnatomic = document.getElementById("btnAnatomic");
  /* ===== Collision limits (dev-tuned) =====
   Only Trunk Lateral Flexion for now (Left/Right have their own caps).
   Values are in degrees.
*/
const COLLIM = {
  enabled: false,           // student toggle
  trunkLatLMax: 30,         // default cap for Left lateral flexion
  trunkLatRMax: 30,         // default cap for Right lateral flexion
  load(){
    try{
      const raw = localStorage.getItem('rometrics_collim');
      if (!raw) return;
      const o = JSON.parse(raw);
      if (typeof o.trunkLatLMax === 'number') this.trunkLatLMax = o.trunkLatLMax;
      if (typeof o.trunkLatRMax === 'number') this.trunkLatRMax = o.trunkLatRMax;
    }catch(e){}
  },
  save(){
    try{
      localStorage.setItem('rometrics_collim', JSON.stringify({
        trunkLatLMax: this.trunkLatLMax,
        trunkLatRMax: this.trunkLatRMax
      }));
    }catch(e){}
  }
};
COLLIM.load();

const antiBox = document.getElementById('antiBox');
if (antiBox){
  antiBox.checked = COLLIM.enabled;
  antiBox.addEventListener('click', (e)=>{
    // SHIFT+Click opens tuner (dev)
    if (e.shiftKey){ e.preventDefault(); toggleCollisionTuner(true); return; }
    COLLIM.enabled = !!antiBox.checked;
    log(`Anticollision ${COLLIM.enabled ? 'ENABLED' : 'DISABLED'}.`);
  });
}

  /* ===== Draggable panel ===== */
  (function(){
    let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
    const onDown = (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY;
      const r = panel.getBoundingClientRect();
      startLeft = r.left; startTop = r.top;
      e.preventDefault();
    };
    const onMove = (e)=>{ if(!dragging) return;
      const dx = e.clientX - sx, dy = e.clientY - sy;
      panel.style.left = Math.max(8, startLeft + dx) + "px";
      panel.style.top = Math.max(8, startTop + dy) + "px";
    };
    const onUp = ()=>{ dragging = false; };
    dragbar.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  })();

  /* ===== Three setup ===== */
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
  camera.position.set(1.6, 1.6, 3.2);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.minDistance = 0.6; controls.maxDistance = 6;
  controls.target.set(0,1.1,0);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.7));
  const key = new THREE.DirectionalLight(0xffffff, 1.2);
  key.position.set(2.5,4,2.5);
  key.castShadow = true;
  key.shadow.mapSize.set(2048,2048);
  key.shadow.camera.near = 0.1; key.shadow.camera.far = 15;
  key.shadow.camera.left = -4; key.shadow.camera.right = 4; key.shadow.camera.top = 4; key.shadow.camera.bottom = -4;
  scene.add(key);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.ShadowMaterial({ opacity: 0.45 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  /* ===== Loader ===== */
  const loader = new GLTFLoader();
  loader.setMeshoptDecoder(MeshoptDecoder);
  const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
  const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

  let model = null, skeleton = null;
  const initialBoneRot = new Map();

  function pickModelUrl(){
    const u = new URL(location.href);
    const q = u.searchParams.get("model");
    if (q && /^https?:\/\//i.test(q)) return q;
    if (q && q.trim()) return new URL(q, location.href).href;
    return "./Athletic_Grace_1006002620_texture.glb";
  }
  let MODEL_URL = pickModelUrl();

  function groundSnap(){
    if (!model) return;
    const box = new THREE.Box3().setFromObject(model);
    const minY = box.min.y;
    if (isFinite(minY)) model.position.y -= minY;
  }

  /* ===== Blender order for Advanced menu ===== */
  const BLENDER_ORDER = [
    "pelvis",
    "spine01","spine02","spine03",
    "neck","head",
    "clavicle_L","upperarm_L","upperarm_twist_L","lowerarm_L","lowerarm_twist_L","hand_L",
    "thumb01_L","thumb02_L","thumb03_L",
    "index00_L","index01_L","index02_L","index03_L",
    "middle00_L","middle01_L","middle02_L","middle03_L",
    "ring00_L","ring01_L","ring02_L","ring03_L",
    "pinky00_L","pinky01_L","pinky02_L","pinky03_L",
    "clavicle_R","upperarm_R","upperarm_twist_R","lowerarm_R","lowerarm_twist_R","hand_R",
    "thumb01_R","thumb02_R","thumb03_R",
    "index00_R","index01_R","index02_R","index03_R",
    "middle00_R","middle01_R","middle02_R","middle03_R",
    "ring00_R","ring01_R","ring02_R","ring03_R",
    "pinky00_R","pinky01_R","pinky02_R","pinky03_R",
    "thigh_L","thigh_twist_L","calf_L","calf_twist_L","foot_L","toes_L",
    "thigh_R","thigh_twist_R","calf_R","calf_twist_R","foot_R","toes_R"
  ];
  const ORDER_INDEX = Object.fromEntries(BLENDER_ORDER.map((n,i)=>[n.toLowerCase(), i]));

  /* ===== Populate bones (sorted) ===== */
  function populateBones(){
    boneSel.innerHTML = "";
    if (!skeleton) {
      const o = document.createElement("option");
      o.value = ""; o.textContent = "(No skeleton)";
      boneSel.appendChild(o);
      return;
    }
    const bones = [...skeleton.bones].sort((a,b)=>{
      const ai = ORDER_INDEX[(a.name||"").toLowerCase()];
      const bi = ORDER_INDEX[(b.name||"").toLowerCase()];
      const av = (ai===undefined) ? 9999 : ai;
      const bv = (bi===undefined) ? 9999 : bi;
      if (av!==bv) return av-bv;
      return (a.name||"").localeCompare(b.name||"");
    });

    bones.forEach((b,i)=>{
      const o = document.createElement("option");
      o.value = String(skeleton.bones.indexOf(b));
      o.textContent = b.name || `Bone ${i}`;
      boneSel.appendChild(o);
      if (!initialBoneRot.has(b)) initialBoneRot.set(b, b.quaternion.clone());
    });
    if (skeleton.bones.length) boneSel.value = boneSel.options[0].value;
    rx.value = "0"; ry.value = "0"; rz.value = "0";
    setBoneRotationFromUI();
  }
  function setBoneRotationFromUI(){
    const idx = parseInt(boneSel.value||"-1",10);
    if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;
    const b = skeleton.bones[idx];
    const ex = THREE.MathUtils.degToRad(parseFloat(rx.value)||0);
    const ey = THREE.MathUtils.degToRad(parseFloat(ry.value)||0);
    const ez = THREE.MathUtils.degToRad(parseFloat(rz.value)||0);
    const qDelta = new THREE.Quaternion().setFromEuler(new THREE.Euler(ex,ey,ez,"XYZ"));
    const qBase = initialBoneRot.get(b) || new THREE.Quaternion();
    b.quaternion.copy(qBase).multiply(qDelta);
  }
  function zeroSelectedBone(){
    const idx = parseInt(boneSel.value||"-1",10);
    if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;
    const b = skeleton.bones[idx];
    const qb = initialBoneRot.get(b);
    if (qb) b.quaternion.copy(qb);
    rx.value="0"; ry.value="0"; rz.value="0";
  }
function resetAllBonesToInitial(){
  if (!skeleton) return;
  // Restore every bone to its captured initial quaternion
  skeleton.bones.forEach(b=>{
    const q0 = initialBoneRot.get(b);
    if (q0) b.quaternion.copy(q0);
  });
  // Refresh all joint bind baselines to match the reset pose
  JOINT_BIND.forEach(obj=>{
    if (obj?.bone) obj.qBind = obj.bone.quaternion.clone();
  });
}
  /* ===== Rig profile & axis ===== */
  let RIG_PROFILE = 'generic';
  function detectRigProfile(){
    const names = skeleton?.bones.map(b=>b.name.toLowerCase()).join(' ') || '';
    if (/\bmixamorig\b/.test(names)) RIG_PROFILE = 'mixamo';
    else RIG_PROFILE = 'generic';
    log(`Rig profile: ${RIG_PROFILE}`);
  }
  function axisFor(profile, key, defAxis){
    if (profile==='mixamo'){
      const map = {
        sh_fe_l:'x', sh_fe_r:'x',
        sh_aa_l:'z', sh_aa_r:'z',
        sh_irer_l:'y', sh_irer_r:'y',
        el_fe_l:'x', el_fe_r:'x',
        fa_ps_l:'y', fa_ps_r:'y',
        wr_ps_l:'y', wr_ps_r:'y',
        wr_fe_l:'x', wr_fe_r:'x',
        wr_ru_l:'z', wr_ru_r:'z',
        hip_fe_l:'x', hip_fe_r:'x',
        hip_aa_l:'z', hip_aa_r:'z',
        hip_irer_l:'y', hip_irer_r:'y',
        knee_fe_l:'x', knee_fe_r:'x',
        ankle_dfpf_l:'x', ankle_dfpf_r:'x',
        foot_invev_l:'z', foot_invev_r:'z',
        trunk_fe:'x', trunk_lat:'z', trunk_rot:'y',
        cerv_fe:'x',  cerv_lat:'z',  cerv_rot:'y'
      };
      if (key in map) return map[key];
    }
    return defAxis;
  }

  /* ===== Bone finding ===== */
  // removed "spine" from exclude so trunk can bind
  const EXCLUDE = /(pelvis|root|clavicle|scapula)/i;
  function sideRegex(side){
    if (!side) return [/.*/];
    return side==='l'
      ? [/\bleft\b/i, /\b_left\b/i, /\.l\b/i, /_l\b/i, /\bl\b(?![a-z])/i, /mixamorig:.*left/i]
      : [/\bright\b/i, /\b_right\b/i, /\.r\b/i, /_r\b/i, /\br\b(?![a-z])/i, /mixamorig:.*right/i];
  }
  function findBoneBy(cfg){
    if (!skeleton) return null;
    const names = skeleton.bones.map(b=>b.name.toLowerCase());
    const sideREs = sideRegex(cfg.side);

    const HINTS = cfg.hints || [];
    // Try exact preferred spine chain first for trunk/cervical
    const preferred = (/^trunk_/.test(cfg.key)) ? [/^spine01$/] :
                      (/^cerv_/.test(cfg.key))  ? [/^neck$/, /^head$/] : [];

    const tryList = preferred.length ? [...preferred, ...HINTS] : HINTS;

    for (const cand of tryList){
      for (let i=0;i<names.length;i++){
        if (EXCLUDE.test(names[i])) continue;
        if (cfg.side && !sideREs.some(r=>r.test(names[i])) ) continue;
        if (cand.test(names[i])) return skeleton.bones[i];
      }
    }
    if (!cfg.side){
      for (const cand of tryList){
        for (let i=0;i<names.length;i++){
          if (EXCLUDE.test(names[i])) continue;
          if (cand.test(names[i])) return skeleton.bones[i];
        }
      }
    }
    return null;
  }

  /* ===== DRUJ proxy ===== */
  const DRUJ = { l:null, r:null };
  function ensureDRUJProxy(side){
    if (!skeleton) return null;
    if (DRUJ[side]) return DRUJ[side];
    const handCfg = { side, hints:[/hand|wrist/i] };
    let hand = findBoneBy(handCfg);
    if (!hand) return null;
    const pivot = new THREE.Object3D();
    const parent = hand.parent; if (!parent) return null;
    parent.add(pivot);
    pivot.position.copy(hand.position);
    pivot.quaternion.copy(hand.quaternion);
    pivot.scale.copy(hand.scale);
    pivot.add(hand);
    hand.position.set(0,0,0); hand.quaternion.identity(); hand.scale.set(1,1,1);
    initialBoneRot.set(pivot, pivot.quaternion.clone());
    DRUJ[side] = { pivot };
    log(`Created DRUJ proxy for ${side.toUpperCase()}`);
    return DRUJ[side];
  }

  const JOINT_BIND = new Map();
  function resolveBind(key,cfg){
    if (JOINT_BIND.has(key)) return JOINT_BIND.get(key);
    // Force Trunk to spine01 explicitly (matches Advanced control)
if (/^trunk_/.test(key)) {
  const b = getExactBoneByName('spine01');
  if (b) {
    const qBind = (initialBoneRot.get(b) || b.quaternion.clone()).clone();
    const axis = axisFor(RIG_PROFILE, key, ({sagittal:'x', frontal:'z', transverse:'y'})[cfg.plane] || 'x');
    const obj = { bone: b, qBind, axis };
    JOINT_BIND.set(key, obj);
    log(`Bound ${key} â†’ spine01 (axis ${axis}) [hard-bind]`);
    return obj;
  }
}
    let bone = findBoneBy({...cfg, key});

    if ((!bone) && (key==='wr_ps_l' || key==='fa_ps_l')) { const p=ensureDRUJProxy('l'); bone=p&&p.pivot; }
    if ((!bone) && (key==='wr_ps_r' || key==='fa_ps_r')) { const p=ensureDRUJProxy('r'); bone=p&&p.pivot; }

    if (!bone) { log(`No bind for ${key}`); return null; }
    const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();
    const baseAxis = ({sagittal:'x',frontal:'z',transverse:'y'})[cfg.plane] || 'x';
    const axis = axisFor(RIG_PROFILE, key, baseAxis);
    const obj = {bone, qBind, axis};
    JOINT_BIND.set(key,obj);
    log(`Bound ${key} â†’ ${bone.name} (axis ${axis})`);
    return obj;
  }

  // Freeze current bone pose as baseline (0Â° = current)
  function freezeBindBaseFor(key,cfg){
    const b = resolveBind(key,cfg);
    if (!b) return;
    b.qBind = b.bone.quaternion.clone();
  }

  function applyPairAngle(key,cfg,deg){
    const bind = resolveBind(key,cfg); if (!bind) return;
    const {bone, qBind, axis} = bind;
    const rad = THREE.MathUtils.degToRad(deg + (cfg.neutral||0));
    const e = new THREE.Euler(
      axis==='x'?rad:0,
      axis==='y'?rad:0,
      axis==='z'?rad:0,
      "XYZ"
    );
    const qDelta = new THREE.Quaternion().setFromEuler(e);
    bone.quaternion.copy(qBind).multiply(qDelta);
  }

  /* ===== Motions (paired configs; UI splits) ===== */
  const UPPER = [
    {key:'trunk_fe',  pair:'Trunk â€” Flex / Ext',            side:'', plane:'sagittal',   neutral:0, min:-60, max:80,  hints:[/^spine01$/i]},
    {key:'trunk_lat', pair:'Trunk â€” Lateral Bend (L / R)',  side:'', plane:'frontal',    neutral:0, min:-40, max:40,  hints:[/^spine01$/i]},
    {key:'trunk_rot', pair:'Trunk â€” Rotation (L / R)',      side:'', plane:'transverse', neutral:0, min:-45, max:45,  hints:[/^spine01$/i]},

    {key:'cerv_fe',   pair:'Cervical Flex / Ext',                side:'', plane:'sagittal',   neutral:0, min:-60,  max:70,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_lat',  pair:'Cervical Lat Flex (L / R)',          side:'', plane:'frontal',    neutral:0, min:-45,  max:45,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_rot',  pair:'Cervical Rotation (L / R)',          side:'', plane:'transverse', neutral:0, min:-80,  max:80,  hints:[/^neck$|cspine|head/i]},

    {key:'sh_fe_l',   pair:'Shoulder L â€” Flex / Ext',            side:'l', plane:'sagittal',  neutral:0, min:-180, max:60,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_fe_r',   pair:'Shoulder R â€” Flex / Ext',            side:'r', plane:'sagittal',  neutral:0, min:-180, max:60,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_l',   pair:'Shoulder L â€” Abd / Add',             side:'l', plane:'frontal',   neutral:0, min:-180, max:40,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_r',   pair:'Shoulder R â€” Abd / Add',             side:'r', plane:'frontal',   neutral:0, min:-180, max:40,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_l', pair:'Shoulder L â€” Internal / External',   side:'l', plane:'transverse',neutral:0, min:-70,  max:90,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_r', pair:'Shoulder R â€” Internal / External',   side:'r', plane:'transverse',neutral:0, min:-70,  max:90,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},

    {key:'el_fe_l',   pair:'Elbow L â€” Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-150, max:10,  hints:[/lowerarm|forearm|ulna|radius/i]},
    {key:'el_fe_r',   pair:'Elbow R â€” Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-150, max:10,  hints:[/lowerarm|forearm|ulna|radius/i]},

    {key:'fa_ps_l',   pair:'Forearm L â€” Pronation / Supination', side:'l', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/forearm|radius|ulna|wrist|hand/i]},
    {key:'fa_ps_r',   pair:'Forearm R â€” Pronation / Supination', side:'r', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/forearm|radius|ulna|wrist|hand/i]},

    {key:'wr_ps_l',   pair:'Wrist L â€” Pronation / Supination',   side:'l', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_ps_r',   pair:'Wrist R â€” Pronation / Supination',   side:'r', plane:'transverse',neutral:0, min:-85,  max:95,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},

    {key:'wr_fe_l',   pair:'Wrist L â€” Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-80,  max:70,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_fe_r',   pair:'Wrist R â€” Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-80,  max:70,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_ru_l',   pair:'Wrist L â€” Radial / Ulnar Dev',       side:'l', plane:'frontal',   neutral:0, min:-20,  max:40,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
    {key:'wr_ru_r',   pair:'Wrist R â€” Radial / Ulnar Dev',       side:'r', plane:'frontal',   neutral:0, min:-20,  max:40,  hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i]},
  ];

  const LOWER = [
    {key:'hip_fe_l',   pair:'Hip L â€” Flex / Ext',                side:'l', plane:'sagittal',  neutral:0, min:-120, max:30,  hints:[/thigh|femur/i]},
    {key:'hip_fe_r',   pair:'Hip R â€” Flex / Ext',                side:'r', plane:'sagittal',  neutral:0, min:-120, max:30,  hints:[/thigh|femur/i]},
    {key:'hip_aa_l',   pair:'Hip L â€” Abd / Add',                 side:'l', plane:'frontal',   neutral:0, min:-45,  max:30,  hints:[/thigh|femur/i]},
    {key:'hip_aa_r',   pair:'Hip R â€” Abd / Add',                 side:'r', plane:'frontal',   neutral:0, min:-45,  max:30,  hints:[/thigh|femur/i]},
    {key:'hip_irer_l', pair:'Hip L â€” Internal / External',       side:'l', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},
    {key:'hip_irer_r', pair:'Hip R â€” Internal / External',       side:'r', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},

    {key:'knee_fe_l',  pair:'Knee L â€” Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-150, max:5,   hints:[/calf|tibia|fibula|shin/i]},
    {key:'knee_fe_r',  pair:'Knee R â€” Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-150, max:5,   hints:[/calf|tibia|fibula|shin/i]},

    {key:'ankle_dfpf_l', pair:'Ankle L â€” Dorsi / Plantarflex',   side:'l', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'ankle_dfpf_r', pair:'Ankle R â€” Dorsi / Plantarflex',   side:'r', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'foot_invev_l', pair:'Foot L â€” Inversion / Eversion',   side:'l', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
    {key:'foot_invev_r', pair:'Foot R â€” Inversion / Eversion',   side:'r', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
  ];

  let CURRENT = UPPER;

  /* ===== Build separated entries (Trunk & Cervical included) ===== */
  function dirEntriesFromPair(cfg){
    const absMin = Math.abs(cfg.min);
    const maxPos = cfg.max;
    const out = [];
    const push = (label, sign, maxVal) => out.push({ key: cfg.key, cfg, label, sign, max: maxVal });

    if (/_fe_/.test(cfg.key) || cfg.key==='trunk_fe' || cfg.key==='cerv_fe'){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Flexion'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Extension'), -1, absMin);
    } else if (/_aa_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Abduction'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Adduction'), -1, absMin);
    } else if (/_irer_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Internal Rotation'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” External Rotation'), -1, absMin);
    } else if (cfg.key==='trunk_lat' || cfg.key==='cerv_lat'){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Left Lateral Flexion'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Right Lateral Flexion'), -1, absMin);
    } else if (cfg.key==='trunk_rot' || cfg.key==='cerv_rot' || /fa_ps_|wr_ps_/.test(cfg.key)){
      const isRot = (cfg.key==='trunk_rot'||cfg.key==='cerv_rot');
      push(cfg.pair.replace(/â€”.*$/, isRot?'â€” Right Rotation':'â€” Supination'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, isRot?'â€” Left Rotation':'â€” Pronation'), -1, absMin);
    } else if (/wr_fe_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Flexion'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Extension'), -1, absMin);
    } else if (/wr_ru_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Ulnar Deviation'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Radial Deviation'), -1, absMin);
    } else if (/ankle_dfpf_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Plantarflexion'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Dorsiflexion'), -1, absMin);
    } else if (/foot_invev_/.test(cfg.key)){
      push(cfg.pair.replace(/â€”.*$/, 'â€” Eversion'), +1, maxPos);
      push(cfg.pair.replace(/â€”.*$/, 'â€” Inversion'), -1, absMin);
    }
    return out;
  }

  function buildSeparatedCatalog(list){
    const cat = {};
    const add = (grp, entries)=>{ if (!cat[grp]) cat[grp]=[]; cat[grp].push(...entries); };
    list.forEach(cfg=>{
      if (/^trunk_/.test(cfg.key)) add('Trunk', dirEntriesFromPair(cfg));
      else if (/^cerv_/.test(cfg.key)) add('Cervical', dirEntriesFromPair(cfg));
      else if (/^sh_/.test(cfg.key)) add('Shoulder', dirEntriesFromPair(cfg));
      else if (/^el_/.test(cfg.key)) add('Elbow', dirEntriesFromPair(cfg));
      else if (/^fa_/.test(cfg.key)) add('Forearm', dirEntriesFromPair(cfg));
      else if (/^wr_/.test(cfg.key)) add('Wrist', dirEntriesFromPair(cfg));
      else if (/^hip_/.test(cfg.key)) add('Hip', dirEntriesFromPair(cfg));
      else if (/^knee_/.test(cfg.key)) add('Knee', dirEntriesFromPair(cfg));
      else if (/^ankle_/.test(cfg.key)) add('Ankle', dirEntriesFromPair(cfg));
      else if (/^foot_/.test(cfg.key)) add('Foot', dirEntriesFromPair(cfg));
    });
    return cat;
  }

  let CURRENT_ACTION = null; // {mode:'sep', key,cfg,sign,max,label}
  function cfgFromKey(k){ return [...UPPER,...LOWER].find(x=>x.key===k) || null; }

  function fillActionMenu(){
    actionSel.innerHTML = "";
    const ph = document.createElement("option");
    ph.value = ""; ph.textContent = "(Select a motionâ€¦)";
    actionSel.appendChild(ph);

    const list = (CURRENT===UPPER) ? UPPER : LOWER;
    const catalog = buildSeparatedCatalog(list);
    Object.keys(catalog).forEach(group=>{
      const og = document.createElement("optgroup"); og.label = group;
      catalog[group].forEach(entry=>{
        const opt = document.createElement("option");
        opt.value = `sep:${entry.key}:${entry.sign}:${entry.max}`;
        opt.textContent = entry.label;
        og.appendChild(opt);
      });
      actionSel.appendChild(og);
    });

    actionSel.value = "";
    pairLabel.textContent = "Angle (Â°)";
    actionDeg.disabled = true;
    zeroAction.disabled = true;
    CURRENT_ACTION = null;
  }

function syncActionUI(forceZero=false){
  if (!CURRENT_ACTION){
    actionDeg.disabled = true;
    zeroAction.disabled = true;
    if (zeroAll) zeroAll.disabled = false;   // always allowed
    pairLabel.textContent = "Angle (Â°)";
    return;
  }
  pairLabel.textContent = `${CURRENT_ACTION.label} â€” Angle (Â°)`;
  actionDeg.min = "0";
  actionDeg.max = String(CURRENT_ACTION.max);
  if (forceZero) actionDeg.value = "0";
  actionDeg.disabled = false;
  zeroAction.disabled = false;
  if (zeroAll) zeroAll.disabled = false;     // always allowed
}

  segUpper.onclick = ()=>{ CURRENT = UPPER; segUpper.classList.add('on'); segLower.classList.remove('on'); fillActionMenu(); actionDeg.value='0'; actionDeg.disabled=true; zeroAction.disabled=true; };
  segLower.onclick = ()=>{ CURRENT = LOWER; segLower.classList.add('on'); segUpper.classList.remove('on'); fillActionMenu(); };

  // === Anatomic preset (preloaded; window hidden by default) ===
  const ANAT = { addL:-42, psL:-2, wpsL:-73 };
  function applyAnatomicBaseline(){
    setPair('sh_aa_l', ANAT.addL);
    setPair('sh_aa_r', -ANAT.addL);
    setPair('fa_ps_l', ANAT.psL);
    setPair('fa_ps_r', -ANAT.psL);
    setPair('wr_ps_l', ANAT.wpsL);
    setPair('wr_ps_r', -ANAT.wpsL);
    log(`Anatomic baseline applied (L/R) â†’ ADD ${ANAT.addL}/${-ANAT.addL}, Forearm PS ${ANAT.psL}/${-ANAT.psL}, Wrist PS ${ANAT.wpsL}/${-ANAT.wpsL}`);
  }

  actionSel.addEventListener("change", ()=>{
    // Apply baseline, then freeze so slider 0 = anatomic
    applyAnatomicBaseline();
    CURRENT_ACTION = null;
    const v = actionSel.value || "";
    if (v.startsWith("sep:")){
      const [, key, signStr, maxStr] = v.split(":");
      const cfg = cfgFromKey(key);
      CURRENT_ACTION = {
        mode:'sep',
        key, cfg,
        sign: parseInt(signStr,10),
        max: parseFloat(maxStr),
        label: actionSel.options[actionSel.selectedIndex].textContent
      };
      freezeBindBaseFor(key,cfg);
      syncActionUI(true);
      return;
    }
    syncActionUI(true);
  });

actionDeg.addEventListener("input", ()=>{
  if (!CURRENT_ACTION) return;
  let val = Math.max(0, Math.min(CURRENT_ACTION.max, parseFloat(actionDeg.value)||0));

  // Anticollision enforcement for Trunk Lateral Flexion
  if (COLLIM.enabled && CURRENT_ACTION.key === 'trunk_lat'){
    const cap = (CURRENT_ACTION.sign > 0) ? COLLIM.trunkLatLMax : COLLIM.trunkLatRMax;
    if (val > cap){
      val = cap;
      actionDeg.value = String(val);
      log(`Anticollision limit hit (Trunk Lat ${CURRENT_ACTION.sign>0?'Left':'Right'}): max ${cap}Â°`);
    }
  }

  const signed = CURRENT_ACTION.sign * val;
  applyPairAngle(CURRENT_ACTION.key, CURRENT_ACTION.cfg, signed);
});

  zeroAction.onclick = ()=>{
    if (!CURRENT_ACTION) return;
    actionDeg.value="0";
    applyPairAngle(CURRENT_ACTION.key, CURRENT_ACTION.cfg, 0);
  };
  zeroAll.onclick = ()=>{
  // 1) Zero every joint to its captured neutral
  resetAllBonesToInitial();

  // 2) Re-apply your anatomic baseline (ADD âˆ’42Â°, Forearm PS âˆ’2Â°, Wrist PS âˆ’73Â°)
  applyAnatomicBaseline();

  // 3) Reset UI: clear selection and sliders
  actionSel.value = "";
  actionDeg.value = "0";
  actionDeg.disabled = true;
  zeroAction.disabled = true;
  if (zeroAll) zeroAll.disabled = false;

  // Advanced sliders back to zero
  rx.value = "0"; ry.value = "0"; rz.value = "0";

  pairLabel.textContent = "Angle (Â°)";
  log("All motions zeroed â†’ returned to anatomic baseline.");
};

  /* ===== Model load/reset/reload ===== */
  function clearModel(){
    if (model) scene.remove(model);
    model = null; skeleton = null;
    initialBoneRot.clear(); JOINT_BIND.clear();
    boneSel.innerHTML = "";
    DRUJ.l = DRUJ.r = null;
  }
  function loadModel(){
    msg.textContent = "Loadingâ€¦"; log("Loading model...");
    clearModel();
    loader.load(
      MODEL_URL,
      (gltf) => {
        model = gltf.scene;
        model.traverse(o => {
          if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }
          if (o.isSkinnedMesh && !skeleton) skeleton = o.skeleton;
        });
        scene.add(model);
        groundSnap();
        msg.textContent = "âœ… Model loaded";
        populateBones();
        detectRigProfile();
        fillActionMenu();
      },
      (xhr) => { 
  const pct = xhr.lengthComputable ? Math.min(100, Math.round((xhr.loaded/xhr.total)*100)) : null;
  msg.textContent = pct !== null ? `Loading ${pct}%` : "Loadingâ€¦";
},
      (err) => { console.error(err); msg.textContent = "âš ï¸ Load error"; log(`Error: ${err?.message || err}`); }
    );
  }
  loadModel();

  reloadBtn.onclick = ()=>{ loadModel(); };

  /* ===== Advanced controls wiring ===== */
  boneSel.onchange = ()=>{ rx.value="0"; ry.value="0"; rz.value="0"; setBoneRotationFromUI(); };
  [rx,ry,rz].forEach(el=> el.addEventListener("input", setBoneRotationFromUI));
  [mx,my,mz,ms,myaw].forEach(el => el.addEventListener("input", () => {
    if (!model) return;
    model.position.set(parseFloat(mx.value), parseFloat(my.value), parseFloat(mz.value));
    model.scale.setScalar(parseInt(ms.value,10)/100);
    model.rotation.y = THREE.MathUtils.degToRad(parseFloat(myaw.value));
  }));
  zeroBone.onclick = zeroSelectedBone;
  resetModel.onclick = ()=>{
    mx.value="0"; my.value="0"; mz.value="0.6"; ms.value="125"; myaw.value="0";
    if (model){ model.position.set(0,0,0.6); model.scale.setScalar(1.25); model.rotation.y=0; }
    groundSnap();
  };

  /* ===== Paired-joint helpers ===== */
  function setPair(key,deg){
    if (key === 'wr_ps_l') return rotateSideWristPS('l', deg);
    if (key === 'wr_ps_r') return rotateSideWristPS('r', deg);
    const cfg = cfgFromKey(key);
    if (cfg) applyPairAngle(key,cfg,deg);
  }

  function getExactBoneByName(name){
    if (!skeleton) return null;
    const lname = String(name).toLowerCase();
    return skeleton.bones.find(b => (b.name||'').toLowerCase() === lname) || null;
  }
  function rotateSideWristPS(side, deg){
    if (!skeleton) return;
    let wrist = side === 'l' ? getExactBoneByName('hand_l') : getExactBoneByName('hand_r');
    if (!wrist){
      wrist = findBoneBy({ side, hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i], key: side==='l'?'wr_ps_l':'wr_ps_r' });
    }
    if (!wrist){ log(`No wrist bone for ${side}`); return; }

    const keyForAxis = side === 'l' ? 'fa_ps_l' : 'fa_ps_r';
    const axis = axisFor(RIG_PROFILE, keyForAxis, 'y');
    const qBind = (initialBoneRot.get(wrist) || wrist.quaternion.clone()).clone();
    const rad = THREE.MathUtils.degToRad(deg);
    const e = new THREE.Euler(0,0,0,'XYZ');
    if (axis==='x') e.set(rad,0,0,'XYZ');
    if (axis==='y') e.set(0,rad,0,'XYZ');
    if (axis==='z') e.set(0,0,rad,'XYZ');
    wrist.quaternion.copy(qBind).multiply(new THREE.Quaternion().setFromEuler(e));
    log(`Wrist ${side.toUpperCase()} (hand_${side}) PS = ${deg}Â°`);
  }

  /* ===== Hidden Anatomic Tuner (dev-only) ===== */
  let tunerEl = null, tunerVisible = false;
  function ensureAnatomicTuner(){
    if (tunerEl) return tunerEl;
    tunerEl = document.createElement('div');
    Object.assign(tunerEl.style,{
      position:'fixed', right:'16px', top:'16px', zIndex:40,
      background:'rgba(8,13,26,.96)', border:'1px solid #334155',
      borderRadius:'12px', padding:'10px', width:'280px', color:'#e2e8f0',
      font:'12px/1.3 system-ui,Segoe UI,Roboto', boxShadow:'0 8px 28px rgba(0,0,0,.4)',
      display:'none'  // hidden by default
    });
    tunerEl.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
        <strong style="font-size:13px;">Anatomic Position Tuner (dev)</strong>
        <button id="anatX" title="Close" style="margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:16px;cursor:pointer;">âœ•</button>
      </div>

      <label style="display:block;margin-top:6px;opacity:.8">Shoulder ADD (Â°)</label>
      <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
        <input id="addL" type="number" step="1">
        <input id="addR" type="number" step="1" disabled>
      </div>

      <label style="display:block;opacity:.8">Forearm PS (Â°) â€” sup(+), pro(âˆ’)</label>
      <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
        <input id="psL" type="number" step="1">
        <input id="psR" type="number" step="1" disabled>
      </div>

      <label style="display:block;opacity:.8; margin-top:8px;">Wrist PS (Â°)</label>
      <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
        <input id="wpsL" type="number" step="1">
        <input id="wpsR" type="number" step="1" disabled>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="anatApply" class="mini" style="flex:1">Apply</button>
        <button id="anatZero"  class="mini">Zero</button>
      </div>
    `;
    document.body.appendChild(tunerEl);

    const addL=tunerEl.querySelector('#addL'), addR=tunerEl.querySelector('#addR');
    const psL =tunerEl.querySelector('#psL'),  psR =tunerEl.querySelector('#psR');
    const wpsL=tunerEl.querySelector('#wpsL'), wpsR=tunerEl.querySelector('#wpsR');

    function preload(){
      addL.value = String(ANAT.addL);
      psL.value  = String(ANAT.psL);
      wpsL.value = String(ANAT.wpsL);
      addR.value = String(-ANAT.addL);
      psR.value  = String(-ANAT.psL);
      wpsR.value = String(-ANAT.wpsL);
    }
    function syncRight(){
      addR.value = String(-(+addL.value||0));
      psR.value  = String(-( +psL.value||0));
      wpsR.value = String(-( +wpsL.value||0));
    }
    preload();
    addL.addEventListener('input', syncRight);
    psL.addEventListener('input', syncRight);
    wpsL.addEventListener('input', syncRight);

    tunerEl.querySelector('#anatApply').onclick = ()=>{
      ANAT.addL = +addL.value||0;
      ANAT.psL  = +psL.value||0;
      ANAT.wpsL = +wpsL.value||0;
      applyAnatomicBaseline();
    };
    tunerEl.querySelector('#anatZero').onclick = ()=>{
      addL.value = psL.value = wpsL.value = '0';
      syncRight();
      ANAT.addL = ANAT.psL = ANAT.wpsL = 0;
      applyAnatomicBaseline();
    };
    tunerEl.querySelector('#anatX').onclick = ()=>{
      tunerEl.style.display='none'; tunerVisible=false;
    };
    return tunerEl;
  }

  function toggleTuner(show){
    ensureAnatomicTuner();
    tunerVisible = (show===undefined) ? !tunerVisible : !!show;
    tunerEl.style.display = tunerVisible ? 'block' : 'none';
  }

  btnAnatomic.onclick = (e)=>{
    applyAnatomicBaseline();
    if (e.shiftKey) { toggleTuner(true); } // reveal only on Shift+Click
  };

 /* ===== Collision Tuner (dev-only) ===== */
let colTunerEl = null, colTunerVisible = false;

function ensureCollisionTuner(){
  if (colTunerEl) return colTunerEl;
  colTunerEl = document.createElement('div');
  Object.assign(colTunerEl.style,{
    position:'fixed', right:'16px', top:'220px', zIndex:41,
    background:'rgba(8,13,26,.96)', border:'1px solid #334155',
    borderRadius:'12px', padding:'10px', width:'320px', color:'#e2e8f0',
    font:'12px/1.3 system-ui,Segoe UI,Roboto', boxShadow:'0 8px 28px rgba(0,0,0,.4)',
    display:'none'
  });
  colTunerEl.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
      <strong style="font-size:13px;">Collision Tuner (dev)</strong>
      <span class="badge">Safe ROM Line</span>
      <button id="colX" title="Close" style="margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:16px;cursor:pointer;">âœ•</button>
    </div>

    <div class="rom-row">
      <div class="rom-head">Trunk Lateral Flex â€” Left max (Â°)</div>
      <div style="flex:1"><input id="colTrunkLatL" type="number" step="1" min="0" max="90" style="width:100%"></div>
    </div>
    <div class="rom-row">
      <div class="rom-head">Trunk Lateral Flex â€” Right max (Â°)</div>
      <div style="flex:1"><input id="colTrunkLatR" type="number" step="1" min="0" max="90" style="width:100%"></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:10px;">
      <button id="colApply" class="mini" style="flex:1">Apply</button>
      <button id="colSave"  class="mini">Save</button>
      <button id="colReset" class="mini">Reset</button>
    </div>
    <div style="opacity:.7;margin-top:6px;">
      Tip: with the student checkbox <em>Anticollision</em> ON, these caps are enforced.
      Shift+Click the checkbox to reopen this tuner.
    </div>
  `;
  document.body.appendChild(colTunerEl);

  const colL = colTunerEl.querySelector('#colTrunkLatL');
  const colR = colTunerEl.querySelector('#colTrunkLatR');

  const preload = ()=>{
    colL.value = String(COLLIM.trunkLatLMax);
    colR.value = String(COLLIM.trunkLatRMax);
  };
  preload();

  // === Apply: update caps AND immediately clamp current trunk-lat pose (if active) ===
  colTunerEl.querySelector('#colApply').onclick = ()=>{
    // 1) Update limits from inputs
    COLLIM.trunkLatLMax = Math.max(0, Math.min(90, +colL.value || 0));
    COLLIM.trunkLatRMax = Math.max(0, Math.min(90, +colR.value || 0));

    // 2) If we are currently using Trunk Lateral Flexion, enforce now
    if (CURRENT_ACTION && CURRENT_ACTION.key === 'trunk_lat') {
      let val = Math.max(0, Math.min(CURRENT_ACTION.max, parseFloat(actionDeg.value) || 0));
      const cap = (CURRENT_ACTION.sign > 0) ? COLLIM.trunkLatLMax : COLLIM.trunkLatRMax;

// Preview NOW regardless of checkbox state
if (val > cap){
  val = cap;
  actionDeg.value = String(val);              // reflect in UI
  pairLabel.style.color = '#fca5a5';          // brief visual hint
  setTimeout(()=> pairLabel.style.color = '', 350);
  log(`Previewed Safe ROM Line â†’ ${cap}Â° (${CURRENT_ACTION.sign>0?'Left':'Right'})`);
} else {
  log(`Safe ROM unchanged (â‰¤ ${cap}Â°).`);
}

      // re-apply pose at possibly clamped value
      const signed = CURRENT_ACTION.sign * val;
      applyPairAngle(CURRENT_ACTION.key, CURRENT_ACTION.cfg, signed);
    } else {
      log('Collision limits updated (not on Trunk Lat; enforcement will occur when used).');
    }
  };

  colTunerEl.querySelector('#colSave').onclick = ()=>{
    COLLIM.trunkLatLMax = Math.max(0, Math.min(90, +colL.value || 0));
    COLLIM.trunkLatRMax = Math.max(0, Math.min(90, +colR.value || 0));
    COLLIM.save();
    log('Collision limits saved.');
  };

  colTunerEl.querySelector('#colReset').onclick = ()=>{
    COLLIM.trunkLatLMax = 30; COLLIM.trunkLatRMax = 30;
    COLLIM.save(); preload();
    log('Collision limits reset to defaults (30Â°/30Â°).');
  };

  colTunerEl.querySelector('#colX').onclick = ()=>{ toggleCollisionTuner(false); };
  return colTunerEl;
}

function toggleCollisionTuner(show){
  ensureCollisionTuner();
  colTunerVisible = (show===undefined) ? !colTunerVisible : !!show;
  colTunerEl.style.display = colTunerVisible ? 'block' : 'none';
}
  
  /* ===== ROM modal wiring ===== */
  romBtn.onclick = ()=>{ romModal.classList.add('on'); };
  romClose.onclick = ()=>{ romModal.classList.remove('on'); };
  window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') romModal.classList.remove('on'); });

  /* ===== Resize & render ===== */
  addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  (function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>
