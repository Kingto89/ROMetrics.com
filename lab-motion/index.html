<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3D Motion Lab — Shoulder Flex Fix</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{--bg:#0b1220;--panel:#0f172a;--line:#1f2937;--ctrl:#0b1424;--text:#e2e8f0;--muted:#cbd5e1}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
.panel{position:fixed;left:12px;top:12px;width:380px;max-height:92vh;z-index:10;background:var(--panel);border:1px solid #1114;border-radius:14px;box-shadow:0 10px 30px #0008;display:flex;flex-direction:column}
.hdr{padding:12px 14px;border-bottom:1px solid #0006;font-weight:600}
.body{padding:12px 14px;gap:8px;display:flex;flex-direction:column;overflow:auto}
label{font-size:12px;color:var(--muted);margin-top:6px}
select,input[type=range],input[type=text]{width:100%;background:var(--ctrl);border:1px solid #1b2434;color:var(--text);padding:8px;border-radius:8px}
input[type=range]{height:28px}
.seg{display:flex;gap:6px}
.seg button{flex:1;background:#0b1424;border:1px solid #283244;color:var(--text);padding:6px 8px;border-radius:8px;cursor:pointer}
.seg button.on{outline:2px solid #6aa2ff55;background:#0e1a2e}
.row{display:flex;gap:8px;align-items:center}
.mini{padding:6px 10px;background:#16233a;border:1px solid #24324a;border-radius:8px;color:var(--text);cursor:pointer}
small{opacity:.75}
#log{font-family:ui-monospace,Consolas,monospace;font-size:12px;background:#080e1c;border-top:1px solid #0006;padding:8px;max-height:150px;overflow:auto;white-space:pre-wrap}
.err{color:#ff8080}
.ok{color:#8ff58f}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="panel">
  <div class="hdr">3D Motion Lab — Shoulder Flex</div>
  <div class="body">
    <label>Action</label>
    <select id="actionSel">
      <option value="">— Select —</option>
      <option value="sep:sh_fe_l">Shoulder Flex — Left</option>
      <option value="sep:sh_fe_r">Shoulder Flex — Right</option>
    </select>

    <div class="row">
      <input id="modelUrl" placeholder="Model URL" value="assets/Roma_ROMetrics.glb" />
      <button id="modelLoad" class="mini">Load</button>
    </div>

    <label id="pairLabel">Angle (°)</label>
    <input type="range" id="actionDeg" min="-180" max="180" step="1" value="0" disabled/>

    <!-- Shoulder Flexion — Manual Tuner -->
    <details id="shFlexManual" style="display:none;margin-top:6px;">
      <summary>Shoulder Flexion — Manual Finish</summary>
      <label>Side</label>
      <div class="seg">
        <button id="shFlexSideL" class="on">Left</button>
        <button id="shFlexSideR">Right</button>
      </div>

      <label style="margin-top:6px">Flexion (°)</label>
      <input type="range" id="shFlexVal" min="0" max="180" step="1" value="0">

      <div class="row" style="margin-top:6px">
        <div style="flex:1">
          <label>UpperArm — Rotate X (°)</label>
          <input type="range" id="shUX" min="-60" max="60" step="1" value="0">
        </div>
        <div style="flex:1">
          <label>UpperArm — Rotate Y (°)</label>
          <input type="range" id="shUY" min="-60" max="60" step="1" value="0">
        </div>
      </div>
      <label>UpperArm — Rotate Z (°)</label>
      <input type="range" id="shUZ" min="-60" max="60" step="1" value="25">

      <div class="row" style="margin-top:6px">
        <button id="shFlexReset" class="mini">Reset</button>
        <button id="shFlexHide" class="mini">Hide</button>
      </div>
      <small>Tip: Pure GH flex to ~100°, then finish with UpperArm Z to avoid clavicle collision.</small>
    </details>

    <div class="row">
      <button id="zeroAll" class="mini">Zero All</button>
    </div>
  </div>
  <div id="log"></div>
</div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

// ===== scene =====
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1220);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0.9, 1.5, 2.3);

const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(2,4,3);
dir.castShadow = true;
scene.add(dir);

const grid = new THREE.GridHelper(10, 10, 0x234, 0x123);
grid.material.opacity = 0.25; grid.material.transparent = true;
scene.add(grid);

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ===== ui =====
const logEl = document.getElementById('log');
function log(m, cls){ const span=document.createElement('div'); span.textContent=m; if(cls) span.className=cls; logEl.appendChild(span); logEl.scrollTop=logEl.scrollHeight; }

const actionSel = document.getElementById('actionSel');
const actionDeg = document.getElementById('actionDeg');
const pairLabel = document.getElementById('pairLabel');
const zeroAll   = document.getElementById('zeroAll');

const modelUrl  = document.getElementById('modelUrl');
const modelLoad = document.getElementById('modelLoad');

const shFlexManual = document.getElementById('shFlexManual');
const shFlexSideL  = document.getElementById('shFlexSideL');
const shFlexSideR  = document.getElementById('shFlexSideR');
const shFlexVal    = document.getElementById('shFlexVal');
const shUX         = document.getElementById('shUX');
const shUY         = document.getElementById('shUY');
const shUZ         = document.getElementById('shUZ');
const shFlexReset  = document.getElementById('shFlexReset');
const shFlexHide   = document.getElementById('shFlexHide');

// ===== model loading =====
function resolveModelUrl(){
  try{
    const u = new URL(location.href);
    const q = u.searchParams.get("model");
    if (q && /^https?:\/\//i.test(q)) return q;
    if (q && q.trim()) return new URL(q, location.href).href;
  }catch(e){}
  return "assets/Roma_ROMetrics.glb";
}

let model=null, skeleton=null;
const bindQ = new Map();

function clearModel(){
  if (model) scene.remove(model);
  model=null; skeleton=null; bindQ.clear();
}

function rememberBindPose(root){
  root.traverse(o=>{
    if (o.isBone) bindQ.set(o.name, o.quaternion.clone());
    if (o.isSkinnedMesh && !skeleton) skeleton=o.skeleton;
  });
}

function getBone(name){ return model?.getObjectByName(name) || null; }

const loader = new GLTFLoader();
function loadModel(url){
  const finalUrl = url || resolveModelUrl();
  log(`[Model] Loading ${finalUrl} …`);
  loader.load(finalUrl, (gltf)=>{
    clearModel();
    model = gltf.scene;
    model.traverse(o=>{ if(o.isMesh){o.castShadow=true; o.receiveShadow=true;} });
    scene.add(model);
    rememberBindPose(model);
    log("[Model] Loaded.", "ok");
    enableUI();
  }, (xhr)=>{
    const pct = xhr.lengthComputable ? Math.round((xhr.loaded/xhr.total)*100) : null;
    if (pct!=null) log(`[Model] ${pct}%`);
  }, (err)=>{
    console.error(err);
    log(`[Model] Load error → ${finalUrl}`, "err");
  });
}
modelLoad.onclick = (e)=>{ e.preventDefault(); loadModel(modelUrl.value.trim()); };

// ===== actions =====
let CURRENT_ACTION=null;

actionSel.addEventListener('change', ()=>{
  CURRENT_ACTION = null;
  const v = actionSel.value || "";
  if (!v){ actionDeg.disabled=true; hideTuner(); return; }
  const parts = v.split(":"); const key = parts[1];
  CURRENT_ACTION = { key };
  actionDeg.disabled = false;
  actionDeg.value = "0";
  pairLabel.textContent = "Angle (°)";
  if (key==='sh_fe_l' || key==='sh_fe_r'){ setSide(key.endsWith('_l')?'L':'R'); showTuner(); } else hideTuner();
  applyFromUI();
});

actionDeg.addEventListener('input', applyFromUI);

function enableUI(){ actionSel.disabled=false; }

function resetAll(){
  if (!model) return;
  model.traverse(o=>{
    if (o.isBone){
      const q = bindQ.get(o.name);
      if (q) o.quaternion.copy(q);
    }
  });
}

function applyFromUI(){
  if (!CURRENT_ACTION || !model) return;
  resetAll();
  const key = CURRENT_ACTION.key;
  const deg = parseInt(actionDeg.value||"0",10);
  if (key==='sh_fe_l' || key==='sh_fe_r'){
    applyShoulderFlex(key, deg);
  }
  if (isTunerVisible()){
    const {x,y,z} = SH_FLEX_MAN.vals[SH_FLEX_MAN.side];
    applyUpperarmXYZ(SH_FLEX_MAN.side, x, y, z);
  }
}

const FLEX_AXIS='x'; // change if your rig differs
function applyShoulderFlex(key, deg){
  const side = key.endsWith('_l') ? 'L' : 'R';
  const humName = side==='L' ? 'upperarm_L' : 'upperarm_R';
  const hum = getBone(humName); if (!hum){ log(`[Flex] Missing ${humName}`, "err"); return; }
  const qBind = bindQ.get(humName) || hum.quaternion.clone();
  const rad = THREE.MathUtils.degToRad(deg);
  const e = new THREE.Euler(
    FLEX_AXIS==='x'?rad:0,
    FLEX_AXIS==='y'?rad:0,
    FLEX_AXIS==='z'?rad:0,
    "XYZ"
  );
  const q = new THREE.Quaternion().setFromEuler(e);
  hum.quaternion.copy(qBind).multiply(q);
}

function applyUpperarmXYZ(side, xDeg, yDeg, zDeg){
  const humName = side==='L' ? 'upperarm_L' : 'upperarm_R';
  const hum = getBone(humName); if (!hum) return;
  const ex = THREE.MathUtils.degToRad(xDeg||0);
  const ey = THREE.MathUtils.degToRad(yDeg||0);
  const ez = THREE.MathUtils.degToRad(zDeg||0);
  const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(ex,ey,ez,"XYZ"));
  hum.quaternion.multiply(q);
}

// ===== tuner =====
const SH_FLEX_MAN = {
  side: 'L',
  vals: { L:{flex:0,x:0,y:0,z:25}, R:{flex:0,x:0,y:0,z:25} }
};

function setSide(s){
  SH_FLEX_MAN.side=s;
  shFlexSideL.classList.toggle('on', s==='L');
  shFlexSideR.classList.toggle('on', s==='R');
  syncTuner();
}
function syncTuner(){
  const v = SH_FLEX_MAN.vals[SH_FLEX_MAN.side];
  shFlexVal.value=String(v.flex);
  shUX.value=String(v.x);
  shUY.value=String(v.y);
  shUZ.value=String(v.z);
}
function readTuner(){
  const v = SH_FLEX_MAN.vals[SH_FLEX_MAN.side];
  v.flex = parseInt(shFlexVal.value||'0',10);
  v.x    = parseInt(shUX.value||'0',10);
  v.y    = parseInt(shUY.value||'0',10);
  v.z    = parseInt(shUZ.value||'0',10);
}
function showTuner(){ shFlexManual.style.display='block'; shFlexManual.open=true; syncTuner(); }
function hideTuner(){ shFlexManual.style.display='none'; shFlexManual.open=false; }
function isTunerVisible(){ return shFlexManual.style.display!=='none'; }

shFlexSideL.onclick = (e)=>{ e.preventDefault(); setSide('L'); applyManual(); };
shFlexSideR.onclick = (e)=>{ e.preventDefault(); setSide('R'); applyManual(); };
[shFlexVal, shUX, shUY, shUZ].forEach(el=> el.addEventListener('input', applyManual));
shFlexReset.onclick = (e)=>{ e.preventDefault(); const s=SH_FLEX_MAN.side; SH_FLEX_MAN.vals[s]={flex:0,x:0,y:0,z:25}; syncTuner(); applyManual(); };
shFlexHide.onclick  = (e)=>{ e.preventDefault(); hideTuner(); };

function applyManual(){
  if (!model) return;
  readTuner();
  // drive main pair
  const side = SH_FLEX_MAN.side;
  const key  = side==='L' ? 'sh_fe_l' : 'sh_fe_r';
  actionSel.value = `sep:${key}`;
  actionDeg.disabled=false;
  actionDeg.value = String(SH_FLEX_MAN.vals[side].flex);
  applyFromUI();
}

zeroAll.onclick = ()=>{
  resetAll();
  actionSel.value=""; actionDeg.value="0"; actionDeg.disabled=true;
  hideTuner();
  log("[Reset] Returned to bind pose.");
};

// ===== start =====
loadModel(resolveModelUrl());

// ===== loop =====
const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const t = clock.getElapsedTime();
  dir.position.x = Math.cos(t*0.2)*3;
  dir.position.z = Math.sin(t*0.2)*3;
  renderer.render(scene, camera);
});
</script>
</body>
</html>
