<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PT Lab ‚Äî Goniometry Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
  canvas{position:fixed; inset:0; z-index:0; width:100%; height:100%; display:block}

  .panel{
    position:fixed; left:0; top:0; bottom:0; width:360px;
    background:#0f172a; border-right:1px solid #1f2937; padding:14px; overflow:auto; z-index:50;
  }
  h3{margin:8px 0 12px 0}
  label{display:block;font-size:13px;margin-top:10px;color:#cbd5e1}
  select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:#1e293b;border:1px solid #334155;color:#e2e8f0}
  .row{display:flex;gap:8px}.row>button{flex:1}
  #log{background:#0b1220;border:1px solid #1f2937;height:130px;overflow:auto;border-radius:8px;padding:8px}
  .hide{display:none}.lockOn{background:#0b3a1f;border-color:#16a34a}

  .pill{display:flex;flex-direction:column;align-items:center;gap:4px;border:2px solid #334155;border-radius:12px;padding:8px 6px;line-height:1}
  .pill .top{display:flex;align-items:center;gap:6px;font-weight:700}
  .pill .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
  .pill.orange{border-color:#f59e0b}.pill .dot.orange{background:#f59e0b}
  .pill.red{border-color:#ef4444}.pill .dot.red{background:#ef4444}
  .pill.green{border-color:#22c55e}.pill .dot.green{background:#22c55e}
  .pill .label{font-size:12px;color:#cbd5e1}

  .hud,.toast,#msg{z-index:40}
  .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-weight:700;backdrop-filter:blur(6px)}
  .toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(2,6,23,.7);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-size:13px;display:none}
  #msg{position:fixed;top:10px;left:10px;background:rgba(15,23,42,.7);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:13px}

  details{border:1px solid #1f2937;border-radius:10px;padding:6px 8px;background:#0b1220}
  details+details{margin-top:8px}
  summary{cursor:pointer;font-weight:600;color:#e2e8f0}
  .group{padding:6px 4px}

  /* Note bubble */
  .note{position:fixed;right:16px;bottom:16px;width:min(520px,90vw);background:rgba(2,6,23,.9);border:1px solid #334155;border-radius:12px;padding:14px 46px 14px 14px;z-index:45;backdrop-filter:blur(6px);max-height:60vh;overflow:auto}
  .note h4{margin:0 0 6px 0}
  .note .x{position:absolute;top:8px;right:10px;width:auto;height:auto;line-height:1;cursor:pointer;border:0;background:transparent;color:#94a3b8;font-size:18px;display:block}
  .note .md *{margin:0 0 6px 0;line-height:1.35}
  .note .md{font-size:13px}
  .note .md ul{padding-left:18px}

  /* SVG */
  #gonioHost{position:fixed; inset:0; z-index:30; pointer-events:none}
  #gonioHost svg{width:100vw;height:100vh;background:transparent;pointer-events:auto}
  .tick{stroke:#64748b;stroke-width:.9}.tickBig{stroke-width:1.6}
  .labelOuter{fill:#e5e7eb;font-size:11px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .labelInner{fill:#fca5a5;font-size:8.2px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .rulerTick{stroke:#94a3b8}
  .ruLbl{fill:#cbd5e1;font-size:9.5px;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .scrLine{stroke-width:2.2; stroke-linecap:round}

  /* Cursors */
  #instrument{cursor:move}
  #armB_handleKnob,#armB_handleShaft,#armB_knob{cursor:grab}
</style>
</head>
<body>
<div class="panel">
  <h3>Goniometry Trainer</h3>

  <label>Region</label>
  <select id="regionSel">
    <option value="cervical_spine">Cervical Spine</option>
    <option value="thoracic_lumbar_spine">Thoracic & Lumbar Spine</option>
    <option value="glenohumeral_joint">Glenohumeral Joint</option>
    <option value="elbow_radioulnar">Elbow & Radioulnar Joints</option>
    <option value="wrist">Wrist</option>
    <option value="hip">Hip</option>
    <option value="knee">Knee</option>
    <option value="talocrural_ankle">Talocrural (Ankle)</option>
    <option value="transverse_tarsal_subtalar">Transverse Tarsal & Subtalar</option>
  </select>

  <label>Motion</label>
  <select id="motionSel"></select>

  <div class="row" style="display:flex; gap:8px;">
  <button id="showNote" style="flex:1; max-width:185px;">üìå Show goniometer placement</button>
  <button id="runAction" style="flex:0 0 120px; background:#1e293b; border:1px solid #334155;">
    ‚ñ∂Ô∏è Run Action
  </button>
</div>


  <div class="row">
    <button class="pill orange" id="pickFulcrum">
      <div class="top"><span class="dot orange"></span><span>1</span></div>
      <div class="label">Fulcrum</div>
    </button>
    <button class="pill red" id="pickStationary">
      <div class="top"><span class="dot red"></span><span>2</span></div>
      <div class="label">Stationary</div>
    </button>
    <button class="pill green" id="pickMoving">
      <div class="top"><span class="dot green"></span><span>3</span></div>
      <div class="label">Moving</div>
    </button>
  </div>

  <label>Range of Motion</label>
  <div class="row">
    <button id="startROM">‚ñ∂Ô∏è Start ROM</button>
    <button id="resetROM">‚Ü∫ Reset ROM</button>
    <button id="resetMeasurement" title="Clear dots + lines + goniometer">üßπ Reset Measurement</button>
  </div>

  <label>Interaction Locks</label>
  <div class="row">
    <button id="lock3D">üîì 3D: Unlocked</button>
    <button id="lockGonio">üîì Gonio Arm: Unlocked</button>
  </div>

  <details id="controllers">
    <summary>üéõÔ∏è Controllers</summary>
    <div class="group">
      <details id="ctrlGonio">
        <summary>üß≠ Goniometer</summary>

        <label>Gonio Size (10‚Äì200%)</label>
        <input type="range" min="10" max="200" step="5" value="100" id="gonioSize">

        <!-- NEW: two straight-line controls (CW/CCW). Old single slider kept hidden for compatibility. -->
        <label>Rotate Moving Arm ‚Äî CW (¬∞)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="rotateCW">
        <label>Rotate Moving Arm ‚Äî CCW (¬∞)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="rotateCCW">

        <input type="range" min="0" max="360" step="1" value="0" id="rotateMove" style="display:none">

        <label>Rotate Goniometer (¬∞)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="rotateGonio">

        <label>Gonio X (px)</label>
        <input type="range" min="0" max="2000" step="1" value="0" id="gonioX">
        <label>Gonio Y (px)</label>
        <input type="range" min="0" max="2000" step="1" value="0" id="gonioY">
      </details>

      <details id="ctrlModel">
        <summary>üßç Model</summary>
        <label>Model X (m)</label>
        <input type="range" min="-2" max="2" step="0.01" value="0" id="modelX">
        <label>Model Z (m)</label>
        <input type="range" min="-2" max="2" step="0.01" value="0.6" id="modelZ">
        <label>Model Y (m) ‚Äî up/down</label>
        <input type="range" min="-0.2" max="0.6" step="0.005" value="0" id="modelY">
        <label>Model Scale (%)</label>
        <input type="range" min="60" max="160" step="1" value="100" id="modelScale">
        <label>Model Yaw (¬∞)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="modelYaw">
        <div class="row" style="margin-top:6px">
          <button id="resetPose">Reset Pose</button>
        </div>
      </details>
    </div>
  </details>

  <label>Event Log</label>
  <pre id="log"></pre>
</div>

<!-- SVG overlay: screen-space dots + lines -->
<div id="gonioHost" class="hide" aria-hidden="true">
  <svg id="gonioSvg" aria-label="Universal goniometer">
    <g id="screenDots">
      <line id="scrLineA" class="scrLine" stroke="#ef4444" x1="0" y1="0" x2="0" y2="0" style="display:none"/>
      <line id="scrLineB" class="scrLine" stroke="#22c55e" x1="0" y1="0" x2="0" y2="0" style="display:none"/>
      <circle id="scrFulcrum" r="6" fill="#f59e0b" cx="-100" cy="-100" style="display:none"/>
      <circle id="scrStationary" r="6" fill="#ef4444" cx="-100" cy="-100" style="display:none"/>
      <circle id="scrMoving" r="6" fill="#22c55e" cx="-100" cy="-100" style="display:none"/>
    </g>
    <g id="viewport" transform="translate(0,0) scale(1)">
      <g id="rotWrap" transform="rotate(0)">
        <g id="mirrorWrap" transform="scale(1,1)">
          <g id="instrument">
            <g id="head">
              <circle r="120" fill="none" stroke="#94a3b8" stroke-width="1.6"/>
              <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
              <g id="ticks"></g>
              <g id="labelsFixed">
                <g id="numsOut"></g>
                <g id="numsInWrap"><g id="numsIn"></g></g>
              </g>
              <circle r="3.2" fill="#94a3b8"/>
            </g>

            <!-- Stationary (red) -->
            <g id="armA_grp">
              <rect x="-10" y="120" width="20" height="260" rx="10" stroke="#ef4444" fill="none" stroke-width="3" />
              <line id="axisA" x1="0" y1="380" x2="0" y2="-116" stroke="#ef4444" stroke-width="1.6" opacity=".85" stroke-linecap="round"/>
              <g id="armA_ruler"></g>
              <circle id="armA_knob" cx="0" cy="380" r="10" fill="#ef4444"/>
            </g>

            <!-- Moving (green) -->
            <g id="armB_grp">
              <rect x="-10" y="-380" width="20" height="500" rx="10" stroke="#22c55e" fill="none" stroke-width="3"/>
              <line id="axisB" x1="0" y1="-380" x2="0" y2="124" stroke="#22c55e" stroke-width="1.6" opacity=".85" stroke-linecap="round"/>
              <g id="armB_ruler"></g>
              <circle id="armB_knob" cx="0" cy="-380" r="10" fill="#22c55e"/>
              <circle id="armB_handleKnob" cx="0" cy="-380" r="38" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
              <rect   id="armB_handleShaft" x="-20" y="-380" width="40" height="500" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
            </g>
          </g>
        </g>
      </g>
    </g>
  </svg>
</div>

<div id="msg">Loading‚Ä¶</div>
<div class="hud" id="hud">Angle: 0¬∞</div>
<div class="toast" id="toast">Preset updated</div>
<canvas id="c"></canvas>

<!-- Note bubble -->
<div id="note" class="note hide">
  <button class="x" id="noteClose">‚úï</button>
  <h4 id="noteTitle">Note</h4>
  <div id="noteBody" class="md">Loading‚Ä¶</div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

/* ===================== CONFIG / UI HOOKS ===================== */
const msg = document.getElementById("msg");
const hud = document.getElementById("hud");
const logEl = document.getElementById("log");
const toast = document.getElementById("toast");

const lock3DBtn = document.getElementById("lock3D");
const lockGonioBtn = document.getElementById("lockGonio");

const sizeEl = document.getElementById("gonioSize");
const rotateMoveEl = document.getElementById("rotateMove"); // hidden legacy control
const rotateGonioEl = document.getElementById("rotateGonio");
const gonioXEl = document.getElementById("gonioX");
const gonioYEl = document.getElementById("gonioY");

/* NEW: two straight-line controls */
const rotateCWEl  = document.getElementById("rotateCW");
const rotateCCWEl = document.getElementById("rotateCCW");

const regionSel = document.getElementById("regionSel");
const motionSel = document.getElementById("motionSel");
let CURRENT_ACTION = null;
const note = document.getElementById("note");
const noteTitle = document.getElementById("noteTitle");
const noteBody = document.getElementById("noteBody");
document.getElementById("noteClose").onclick = ()=> note.classList.add("hide");

const resetROMBtn = document.getElementById("resetROM");
const startROMBtn = document.getElementById("startROM");
const resetMeasurementBtn = document.getElementById("resetMeasurement");
const runActionBtn = document.getElementById("runAction");

const modelX = document.getElementById("modelX");
const modelZ = document.getElementById("modelZ");
const modelY = document.getElementById("modelY");
const modelScale = document.getElementById("modelScale");
const modelYaw = document.getElementById("modelYaw");
const resetPose = document.getElementById("resetPose");

const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

  /* ===== Bone finding ===== */
const EXCLUDE = /(pelvis|root|scapula)/i;
function sideRegex(side){
  if (!side) return [/.*/];
  return side==='l'
    ? [/\bleft\b/i, /\b_left\b/i, /\.l\b/i, /_l\b/i, /\bl\b(?![a-z])/i, /mixamorig:.*left/i]
    : [/\bright\b/i, /\b_right\b/i, /\.r\b/i, /_r\b/i, /\br\b(?![a-z])/i, /mixamorig:.*right/i];
}
function findBoneBy(cfg){
  if (!skeleton) return null;
  const names = skeleton.bones.map(b=>b.name.toLowerCase());
  const sideREs = sideRegex(cfg.side);

  const HINTS = cfg.hints || [];
  const preferred = (/^trunk_/.test(cfg.key)) ? [/^spine01$/] :
                    (/^cerv_/.test(cfg.key))  ? [/^neck$/, /^head$/] : [];
  const tryList = preferred.length ? [...preferred, ...HINTS] : HINTS;

  for (const cand of tryList){
    for (let i=0;i<names.length;i++){
      if (EXCLUDE.test(names[i])) continue;
      if (cfg.side && !sideREs.some(r=>r.test(names[i])) ) continue;
      if (cand.test(names[i])) return skeleton.bones[i];
    }
  }
  if (!cfg.side){
    for (const cand of tryList){
      for (let i=0;i<names.length;i++){
        if (EXCLUDE.test(names[i])) continue;
        if (cand.test(names[i])) return skeleton.bones[i];
      }
    }
  }
  return null;
}
/* ===== DRUJ proxy (kept) ===== */
const DRUJ = { l:null, r:null };
function ensureDRUJProxy(side){
  if (!skeleton) return null;
  if (DRUJ[side]) return DRUJ[side];
  const handCfg = { side, hints:[/hand|wrist/i] };
  let hand = findBoneBy(handCfg);
  if (!hand) return null;
  const pivot = new THREE.Object3D();
  const parent = hand.parent; if (!parent) return null;
  parent.add(pivot);
  pivot.position.copy(hand.position);
  pivot.quaternion.copy(hand.quaternion);
  pivot.scale.copy(hand.scale);
  pivot.add(hand);
  hand.position.set(0,0,0); hand.quaternion.identity(); hand.scale.set(1,1,1);
  initialBoneRot.set(pivot, pivot.quaternion.clone());
  DRUJ[side] = { pivot };
  log(`Created DRUJ proxy for ${side.toUpperCase()}`);
  return DRUJ[side];
}

const JOINT_BIND = new Map();
function resolveBind(key,cfg){
  // --- Clavicle fallback: try real clavicle, else shoulder/collar, else upperarm parent
if (/^clavicle_/.test(key)) {
    const side = /_L$/.test(key) ? 'l' : 'r';
  // try direct clavicle/collar/shoulder
  let bone = findBoneBy({ side, hints:[/clavicle|collar|shoulder/i], key });
  if (!bone) {
    // fallback: take upperarm (humerus) and use its parent as a pseudo-clavicle
    const upper = findBoneBy({ side, hints:[/upperarm|humerus/i], key });
    bone = upper && upper.parent ? upper.parent : upper;
  }
  if (bone) {
    const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();
    const axis = axisFor(RIG_PROFILE, key, 'z'); // allow '-z' mapping
    const obj = { bone, qBind, axis };
    JOINT_BIND.set(key, obj);
    log(`Bound ${key} ‚Üí ${bone.name} (axis ${axis}) [clavicle-fallback]`);
    return obj;
  } else {
    log(`No bind for ${key} (clavicle fallback failed)`);
    return null;
  }
}

  if (JOINT_BIND.has(key)) return JOINT_BIND.get(key);
  if (/^trunk_/.test(key)) {
    const b = getExactBoneByName('spine01');
    if (b) {
      const qBind = (initialBoneRot.get(b) || b.quaternion.clone()).clone();
      const axis = axisFor(RIG_PROFILE, key, ({sagittal:'x', frontal:'z', transverse:'y'})[cfg.plane] || 'x');
      const obj = { bone: b, qBind, axis };
      JOINT_BIND.set(key, obj);
      log(`Bound ${key} ‚Üí spine01 (axis ${axis}) [hard-bind]`);
      return obj;
    }
  }
  let bone = findBoneBy({...cfg, key});
  if ((!bone) && (key==='wr_ps_l' || key==='fa_ps_l')) { const p=ensureDRUJProxy('l'); bone=p&&p.pivot; }
  if ((!bone) && (key==='wr_ps_r' || key==='fa_ps_r')) { const p=ensureDRUJProxy('r'); bone=p&&p.pivot; }
  if (!bone) { log(`No bind for ${key}`); return null; }
  const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();
  const baseAxis = ({sagittal:'x',frontal:'z',transverse:'y'})[cfg.plane] || 'x';
  const axis = axisFor(RIG_PROFILE, key, baseAxis);
  const obj = {bone, qBind, axis};
  JOINT_BIND.set(key,obj);
  log(`Bound ${key} ‚Üí ${bone.name} (axis ${axis})`);
  return obj;
}
function cfgFromKey(k){ 
  return [...UPPER,...LOWER].find(x=>x.key===k) || null; 
}
const ANAT = { addL:-32, psL:-2, wpsL:-73 };
function applyAnatomicBaseline(){
  setPair('sh_aa_l', ANAT.addL);
  setPair('sh_aa_r', ANAT.addL);
  setPair('fa_ps_l', ANAT.psL);
  setPair('fa_ps_r', ANAT.psL);
  setPair('wr_ps_l', ANAT.wpsL);
  setPair('wr_ps_r', -ANAT.wpsL);
  log(`Anatomic baseline applied (same for L/R) ‚Üí ADD ${ANAT.addL}, Forearm PS ${ANAT.psL}, Wrist PS ${ANAT.wpsL}`);
}

  
  /* ===== Collision limits (Safe ROM line; dev-tuned) ===== */
const COLLIM = {
  enabled: false,
  // ===== Existing upper body =====
  trunkLatLMax: 30,
  trunkLatRMax: 30,
  cervRotLMax: 80,
  cervRotRMax: 80,
  shExtLMax: 60, shExtRMax: 60,
  shAddLMax: 30, shAddRMax: 30,
  shFlexLMax: 170, shFlexRMax: 170,
  shAbdLMax: 170, shAbdRMax: 170,
  shIRLMax: 70, shIRRMax: 70,
  shERLMax: 90, shERRMax: 90,
  elExtLMax: 10, elExtRMax: 10,
  elFlexLMax: 150, elFlexRMax: 150,
  wrSupLMax: 95, wrSupRMax: 95,

  // ===== NEW lower body defaults =====
  hipFlexLMax: 110, hipFlexRMax: 110,
  hipExtLMax: 30,  hipExtRMax: 30,
  hipAbdLMax: 45,  hipAbdRMax: 45,
  hipAddLMax: 25,  hipAddRMax: 25,
  hipIRLMax: 45,  hipIRRMax: 45,
  kneeFlexLMax: 150, kneeFlexRMax: 150,
  kneeExtLMax: 5,   kneeExtRMax: 5,
  anklePF_LMax: 50, anklePF_RMax: 50,
  ankleDF_LMax: 20, ankleDF_RMax: 20,
  footInvLMax: 35,  footInvRMax: 35,
  footEvLMax: 20,   footEvRMax: 20,

  load() {
    try {
      const raw = localStorage.getItem('rometrics_collim');
      if (!raw) return;
      const o = JSON.parse(raw);
      Object.keys(this).forEach(k=>{
        if(k!=='enabled'&&k!=='load'&&k!=='save')
          if(typeof o[k]==='number') this[k]=o[k];
      });
    } catch(e){}
  },
  save() {
    try {
      const o={};
      Object.keys(this).forEach(k=>{
        if(typeof this[k]==='number') o[k]=this[k];
      });
      localStorage.setItem('rometrics_collim', JSON.stringify(o));
    } catch(e){}
  }
};
COLLIM.load();

function capFor(action){
  COLLIM.load();  // ‚úÖ refresh saved limits before applying
  if(!COLLIM.enabled || !action) return null; // no cap
  const { key, sign } = action; // sign: +1 or -1
    // Cervical rotation L/R
    if(key==='cerv_rot') return (sign>0) ? COLLIM.cervRotLMax : COLLIM.cervRotRMax; // + = Left, - = Right
       // Shoulder flex/ext ‚Üí cap BOTH flexion (+1) and extension (‚àí1)
    if (/^sh_fe_/.test(key)) {
      const isLeft = key.endsWith('_l');
      if (sign > 0) { // Flexion
        return isLeft ? COLLIM.shFlexLMax : COLLIM.shFlexRMax;
      } else {        // Extension
        return isLeft ? COLLIM.shExtLMax  : COLLIM.shExtRMax;
      }
    }

// Shoulder Abd/Add ‚Äî handle L normally; R corrected
if (/^sh_aa_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (isLeft) {
    // Left: + = Abduction, ‚àí = Adduction (normal)
    return (sign > 0) ? COLLIM.shAbdLMax : COLLIM.shAddLMax;
  } else {
    // ‚úÖ Right side corrected: + = Abduction, ‚àí = Adduction
    return (sign > 0) ? COLLIM.shAddRMax : COLLIM.shAbdRMax;
  }
}

    // Shoulder IR/ER caps
if (/^sh_irer_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (sign > 0) { // Internal Rotation
    return isLeft ? COLLIM.shIRLMax : COLLIM.shIRRMax;
  } else { // External Rotation
    return isLeft ? COLLIM.shERLMax : COLLIM.shERRMax;
  }
}
  // === Elbow Flexion / Extension ===
if (/^el_fe_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (sign > 0) { 
    // Flexion
    return isLeft ? COLLIM.elFlexLMax : COLLIM.elFlexRMax;
  } else if (sign < 0) {
    // Extension
    return isLeft ? COLLIM.elExtLMax : COLLIM.elExtRMax;
  }
}
    // Wrist PS ‚Üí cap supination only. NOTE: in our menu below, Supination is the NEGATIVE direction (sign -1)
    if(/^wr_ps_/.test(key) && sign<0){
      return key.endsWith('_l') ? COLLIM.wrSupLMax : COLLIM.wrSupRMax;
    }
    // Trunk lateral (existing)
    if(key==='trunk_lat') return (sign>0) ? COLLIM.trunkLatLMax : COLLIM.trunkLatRMax;
    // Hip Flexion (both)
if(/^hip_fe_/.test(key)){
  if (sign > 0) return key.endsWith('_l') ? COLLIM.hipFlexLMax : COLLIM.hipFlexRMax;
}
// Hip Abduction / Adduction
if (/^hip_aa_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (isLeft) {
    // Left: + = Abduction, ‚àí = Adduction
    return (sign > 0) ? COLLIM.hipAbdLMax : COLLIM.hipAddLMax;
  } else {
    // Right: + = Adduction, ‚àí = Abduction
    return (sign > 0) ? COLLIM.hipAddRMax : COLLIM.hipAbdRMax;
  }
}
// Hip Internal / External Rotation
if (/^hip_irer_/.test(key)) {
  const isLeft = key.endsWith('_l');
  // symmetric cap for both directions (you can split later if needed)
  return isLeft ? COLLIM.hipIRLMax : COLLIM.hipIRRMax;
}

// Knee Flexion / Extension (only flexion capped)
if(/^knee_fe_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.kneeFlexLMax : COLLIM.kneeFlexRMax;
  if(sign < 0) return null; // no cap on extension
}

// Ankle PF / DF
if(/^ankle_dfpf_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.anklePF_LMax : COLLIM.anklePF_RMax;
  if(sign < 0) return key.endsWith('_l') ? COLLIM.ankleDF_LMax : COLLIM.ankleDF_RMax;
}

// Foot Inversion / Eversion
if(/^foot_invev_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.footEvLMax : COLLIM.footEvRMax;
  if(sign < 0) return key.endsWith('_l') ? COLLIM.footInvLMax : COLLIM.footInvRMax;
}
    return null;
  }

     function applyPairAngle(key, cfg, deg) {
  const bind = resolveBind(key, cfg);
  if (!bind) return;

  const { bone, qBind, axis: rawAxis } = bind;

  // --- Right-shoulder rotation sign corrections ---
  if (key === 'sh_irer_r') deg = -deg;          // Shoulder IR/ER
  if (key === 'sh_aa_r')  deg = -deg;           // Shoulder Abd/Add (reverse direction)

    // --- Right-wrist direction fixes ---
  if (key === 'wr_ps_r') deg = -deg;  // flip pronation/supination
  if (key === 'wr_ru_r') deg = -deg;  // flip radial/ulnar deviation


  const rad = THREE.MathUtils.degToRad(deg + (cfg.neutral || 0));

  // Handle flipped axis (e.g. "-z" for mirrored rig)
  let x = 0, y = 0, z = 0;
  let flip = 1;
  let axis = rawAxis || 'z'; // use mapped axis; default 'z' if missing
  if (axis.startsWith('-')) {
    flip = -1;
    axis = axis.slice(1);
  }

  const r = flip * rad;
  if (axis === 'x') x = r;
  if (axis === 'y') y = r;
  if (axis === 'z') z = r;
  if (axis === 'bone') {
  // rotate around the bone's own local Z axis
  bone.rotateZ(r);
  return;
}

  const e = new THREE.Euler(x, y, z, "XYZ");
  const qDelta = new THREE.Quaternion().setFromEuler(e);
  bone.quaternion.copy(qBind).multiply(qDelta);

  // --- Debug: confirm right-shoulder direction ---
  if (CURRENT_ACTION?.key === "sh_aa_r") {
    console.log(
      `Right-shoulder: ${bone.name}, axis: ${axis}, flipped: ${flip === -1}, deg=${deg}, r=${r.toFixed(3)}`
    );
  }
}

/* ===== Axis profile for rig ===== */
const RIG_PROFILE = {
  trunk:    { x:'+x', y:'+y', z:'+z' },
  cerv:     { x:'+x', y:'+y', z:'+z' },
  clavicle: { x:'+z', y:'+y', z:'+z' },

  shoulder: {
    sh_fe_l : { x:'+x', y:'+y', z:'+z' },
    sh_fe_r : { x:'+x', y:'+y', z:'-z' },
    sh_aa_l : { x:'+z', y:'+y', z:'+z' },
    sh_aa_r : { x:'-z', y:'+y', z:'-z' },
    sh_irer_l:{ x:'+y', y:'+y', z:'+z' },
    sh_irer_r:{ x:'+y', y:'+y', z:'-z' },
  },

  elbow: {
    el_fe_l : { x:'+x', y:'+y', z:'+z' },
    el_fe_r : { x:'+x', y:'+y', z:'-z' },
  },

  wrist: {
    wr_ps_l : { x:'+y', y:'+y', z:'+z' },
    wr_ps_r : { x:'+y', y:'+y', z:'-z' },
    wr_fe_l : { x:'+x', y:'+y', z:'+z' },
    wr_fe_r : { x:'+x', y:'+y', z:'-z' },
    wr_ru_l : { x:'+z', y:'+y', z:'+z' },
    wr_ru_r : { x:'-z', y:'+y', z:'-z' },
  },

  hip: {
    hip_fe_l : { x:'+x', y:'+y', z:'+z' },
    hip_fe_r : { x:'+x', y:'+y', z:'-z' },
    hip_aa_l : { x:'+z', y:'+y', z:'+z' },
    hip_aa_r : { x:'-z', y:'+y', z:'-z' },
    hip_irer_l:{ x:'+y', y:'+y', z:'+z' },
    hip_irer_r:{ x:'+y', y:'+y', z:'-z' },
  },

  knee: {
    knee_fe_l: { x:'+x', y:'+y', z:'+z' },
    knee_fe_r: { x:'+x', y:'+y', z:'-z' },
  },

  ankle: {
    ankle_dfpf_l: { x:'+x', y:'+y', z:'+z' },
    ankle_dfpf_r: { x:'+x', y:'+y', z:'-z' },
    foot_invev_l: { x:'+z', y:'+y', z:'+z' },
    foot_invev_r: { x:'-z', y:'+y', z:'-z' },
  }
};

  /* ===== axis override (rig-profile aware) ===== */
function axisFor(profile, key, base){
  if (!profile) return base;
  const cat = Object.keys(profile).find(k => key.startsWith(k));
  if (!cat) return base;
  const p = profile[cat];
  if (!p) return base;
  const o = p[key];
  if (!o) return base;
  return o[base] || base;
}

  /* ===== Safely apply pair with cap ===== */
function setPair(key, deg){
  const cfg = cfgFromKey(key);
  if (!cfg) return;

  const cap = capFor({key, sign: Math.sign(deg)});
  const use = (typeof cap === 'number')
    ? Math.max(-cap, Math.min(cap, deg))
    : deg;

  applyPairAngle(key, cfg, use);
}

  /* ===== Engine for paired motions ===== */
function applyPair(key, deg){
  const cfg = cfgFromKey(key);
  if (!cfg) return;

  const isL = cfg.side === 'l';
  const sign = Math.sign(deg) || 1;

  const cap = capFor({key, sign});
  const use = (typeof cap === 'number')
    ? Math.max(-cap, Math.min(cap, deg))
    : deg;

  applyPairAngle(key, cfg, use);
}

  /* ===== Automated Action Runner ===== */
function runAutoAction(action){
  if (!action) return;

  const cfg = cfgFromKey(action.key);
  if (!cfg) { log(`‚ùå No cfg for ${action.key}`); return; }

  const dir = action.side === "L" || action.side === "l" ? +1 :
              action.side === "R" || action.side === "r" ? -1 : +1;

  let t = 0;
  const dur = 1.2; // seconds
  const target = cfg.max * dir;

  function easeStep(){
    t += clock.getDelta();
    const k = Math.min(1, t / dur);
    const eased = target * (0.5 - 0.5 * Math.cos(Math.PI * k));
    applyPair(action.key, eased);

    if (k < 1) requestAnimationFrame(easeStep);
  }

  requestAnimationFrame(easeStep);
}

  /* ===== Motions (paired configs; UI splits) ===== */
  const UPPER = [
    {key:'trunk_fe',  pair:'Trunk ‚Äî Flex / Ext',            side:'', plane:'sagittal',   neutral:0, min:-60, max:80,  hints:[/^spine01$/i]},
    {key:'trunk_lat', pair:'Trunk ‚Äî Lateral Bend (L / R)',  side:'', plane:'frontal',    neutral:0, min:-40, max:40,  hints:[/^spine01$/i]},
    {key:'trunk_rot', pair:'Trunk ‚Äî Rotation (L / R)',      side:'', plane:'transverse', neutral:0, min:-45, max:45,  hints:[/^spine01$/i]},

    {key:'cerv_fe',   pair:'Cervical Flex / Ext',                side:'', plane:'sagittal',   neutral:0, min:-60,  max:70,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_lat',  pair:'Cervical Lat Flex (L / R)',          side:'', plane:'frontal',    neutral:0, min:-45,  max:45,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_rot',  pair:'Cervical Rotation (L / R)',          side:'', plane:'transverse', neutral:0, min:-80,  max:80,  hints:[/^neck$|cspine|head/i]},

    {key:'clavicle_L', pair:'Clavicle L ‚Äî Elevation / Depression', side:'l', plane:'frontal', neutral:0, min:-20, max:45, hints:[/clavicle|collar|shoulder|upperarm/i]},
    {key:'clavicle_R', pair:'Clavicle R ‚Äî Elevation / Depression', side:'r', plane:'frontal', neutral:0, min:-20, max:45, hints:[/clavicle|collar|shoulder|upperarm/i]},

    {key:'sh_fe_l',   pair:'Shoulder L ‚Äî Flex / Ext',            side:'l', plane:'sagittal',  neutral:0, min:-60,  max:180, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_fe_r',   pair:'Shoulder R ‚Äî Flex / Ext',            side:'r', plane:'sagittal',  neutral:0, min:-60,  max:180, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_l',   pair:'Shoulder L ‚Äî Abd / Add',             side:'l', plane:'frontal',   neutral:0, min:-30,  max:180, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_r',   pair:'Shoulder R ‚Äî Abd / Add',             side:'r', plane:'frontal',   neutral:0, min:-30,  max:180, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_l', pair:'Shoulder L ‚Äî External / Internal', side:'l', plane:'transverse', neutral:0, min:-90, max:70, hints:[/upperarm_L/i]},
    {key:'sh_irer_r', pair:'Shoulder R ‚Äî External / Internal', side:'r', plane:'transverse', neutral:0, min:-90, max:70, hints:[/upperarm_R/i]},

    // ELBOW ‚Äî fix so Flexion moves (150), Extension small (10)
    {key:'el_fe_l',   pair:'Elbow L ‚Äî Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-10,  max:150, hints:[/lowerarm|forearm|ulna|radius/i]},
    {key:'el_fe_r',   pair:'Elbow R ‚Äî Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-10,  max:150, hints:[/lowerarm|forearm|ulna|radius/i]},

     // ===== Wrist ‚Äî corrected direction for right side =====
    {key:'wr_ps_l', pair:'Wrist L ‚Äî Pronation / Supination', side:'l', plane:'transverse', neutral:0, min:-95, max:85, hints:[/wrist|hand|forearm|radius|ulna/i]},
    {key:'wr_ps_r', pair:'Wrist R ‚Äî Pronation / Supination', side:'r', plane:'transverse', neutral:0, min:-95, max:85, invert:true, hints:[/wrist|hand|forearm|radius|ulna/i]}, // üîÅ flipped

    {key:'wr_fe_l', pair:'Wrist L ‚Äî Flex / Ext', side:'l', plane:'sagittal', neutral:0, min:-70, max:80, hints:[/wrist|hand/i]},
    {key:'wr_fe_r', pair:'Wrist R ‚Äî Flex / Ext', side:'r', plane:'sagittal', neutral:0, min:-70, max:80, hints:[/wrist|hand/i]},

    {key:'wr_ru_l', pair:'Wrist L ‚Äî Radial / Ulnar Dev', side:'l', plane:'frontal', neutral:0, min:-40, max:20, hints:[/wrist|hand/i]},
    {key:'wr_ru_r', pair:'Wrist R ‚Äî Radial / Ulnar Dev', side:'r', plane:'frontal', neutral:0, min:-40, max:20, invert:true, hints:[/wrist|hand/i]}, // üîÅ flipped

];   
  const LOWER = [
    {key:'hip_fe_l',   pair:'Hip L ‚Äî Flex / Ext',                side:'l', plane:'sagittal',  neutral:0, min:-30,  max:120, hints:[/thigh|femur/i]},
    {key:'hip_fe_r',   pair:'Hip R ‚Äî Flex / Ext',                side:'r', plane:'sagittal',  neutral:0, min:-30,  max:120, hints:[/thigh|femur/i]},
    {key:'hip_aa_l',   pair:'Hip L ‚Äî Abd / Add',                 side:'l', plane:'frontal',   neutral:0, min:-30,  max:45,  hints:[/thigh|femur/i]},
    {key:'hip_aa_r', pair:'Hip R ‚Äî Add / Abd', side:'r', plane:'frontal', neutral:0, min:-30, max:45, hints:[/thigh|femur/i]},
    {key:'hip_irer_l', pair:'Hip L ‚Äî Internal / External',       side:'l', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},
    {key:'hip_irer_r', pair:'Hip R ‚Äî Internal / External',       side:'r', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},
    {key:'knee_fe_l', pair:'Knee L ‚Äî Ext / Flex', side:'l', plane:'sagittal', neutral:0, min:-15, max:150, hints:[/calf|tibia|fibula|shin/i]},
    {key:'knee_fe_r', pair:'Knee R ‚Äî Ext / Flex', side:'r', plane:'sagittal', neutral:0, min:-15, max:150, hints:[/calf|tibia|fibula|shin/i]},
    {key:'ankle_dfpf_l', pair:'Ankle L ‚Äî Dorsi / Plantarflex',   side:'l', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'ankle_dfpf_r', pair:'Ankle R ‚Äî Dorsi / Plantarflex',   side:'r', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'foot_invev_l', pair:'Foot L ‚Äî Inversion / Eversion',   side:'l', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
    {key:'foot_invev_r', pair:'Foot R ‚Äî Inversion / Eversion',   side:'r', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
  ];
  
/* Build Motion dropdown using real auto-action catalog */
function refreshMotions(){
  motionSel.innerHTML = "";

  const region = regionSel.value;

  // Filter motions belonging to this region
  const list = ACTIONS.filter(a => a.region === region);

  if (list.length === 0){
    const o = document.createElement("option");
    o.textContent = "(No motions)";
    motionSel.appendChild(o);
    return;
  }

  list.forEach(a => {
    const o = document.createElement("option");
    o.value = a.key;          // store the action key (important)
    o.textContent = a.motion; // readable text shown to user
    motionSel.appendChild(o);
  });
}

refreshMotions();
regionSel.onchange = refreshMotions;


/* ===================== THREE SETUP ===================== */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.domElement.style.touchAction = 'none';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1220);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(1.6, 1.6, 2.8);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = true;
controls.screenSpacePanning = false;
controls.minDistance = 0.8;
controls.maxDistance = 6;
controls.target.set(0, 1.1, 0);

/* Lights + shadow */
scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.7));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(2.5, 4, 2.5);
key.castShadow = true;
key.shadow.mapSize.set(2048,2048);
key.shadow.camera.near = 0.1;
key.shadow.camera.far = 15;
key.shadow.camera.left = -4;
key.shadow.camera.right = 4;
key.shadow.camera.top = 4;
key.shadow.camera.bottom = -4;
scene.add(key);

/* Ground plane */
const groundGeo = new THREE.PlaneGeometry(20, 20);
const groundMat = new THREE.ShadowMaterial({ opacity: 0.45 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.position.y = 0;
ground.receiveShadow = true;
scene.add(ground);

/* ========== Model loader (+ ground-snap) ========== */
const loader = new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

let model = null;
const MODEL_URL = "/ROMetrics.com/assets/Roma_ROMetrics.glb?v=1";
function addFallbackMannequin(){
  if (model) return;
  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color:0xa0a4ae, metalness:0.1, roughness:0.8});
  const mk = (geo,y,s=1)=>{ const m=new THREE.Mesh(geo,mat); m.position.y=y; m.scale.setScalar(s); m.castShadow=true; g.add(m); };
  mk(new THREE.CapsuleGeometry(0.22,0.8,8,16), 1.1);
  mk(new THREE.SphereGeometry(0.16,16,16),        1.8);
  mk(new THREE.CylinderGeometry(0.1,0.12,0.3,12), 1.45);
  mk(new THREE.CylinderGeometry(0.11,0.11,0.8,12),0.55);
  g.traverse(o=>{ if(o.isMesh){ o.castShadow = true; }});
  scene.add(g); model = g; msg.textContent = "‚ö†Ô∏è GLB missing/blocked ‚Äî fallback mannequin shown";
  groundSnap();
}
function groundSnap(){
  if(!model) return;
  const box = new THREE.Box3().setFromObject(model);
  const minY = box.min.y;
  model.position.y -= minY; // feet at y=0
}

async function loadModel() {
  try {
    const head = await fetch(MODEL_URL, { method: "HEAD", cache: "no-store" });
    if (!head.ok) { msg.textContent = `‚ö†Ô∏è ${MODEL_URL} (HTTP ${head.status}) ‚Äî using fallback`; addFallbackMannequin(); return; }
  } catch { msg.textContent = `‚ö†Ô∏è Network error ‚Äî using fallback`; addFallbackMannequin(); return; }

  loader.load(MODEL_URL, (gltf) => {
    model = gltf.scene;
    model.traverse(o=>{ if(o.isMesh){ o.castShadow = true; }});
    scene.add(model);

    groundSnap();
    model.position.x = 0;
    model.position.z = 0.6;
    model.scale.setScalar(1.0);

    controls.target.set(0,1.1,0);
    msg.textContent = "‚úÖ Model loaded";
  }, (xhr) => {
    msg.textContent = xhr.lengthComputable ? `Loading ${Math.round((xhr.loaded/xhr.total)*100)}%` : "Loading‚Ä¶";
  }, () => { msg.textContent = "‚ö†Ô∏è Loader error ‚Äî using fallback"; addFallbackMannequin(); });
  setTimeout(()=>{ if (!model) addFallbackMannequin(); }, 6000);
}
loadModel();

/* ===================== SCREEN-SPACE DOTS (no 3D raycast) ===================== */
const scr = { fulcrum:null, stationary:null, moving:null };
const svg = document.getElementById('gonioSvg');
const scrFulcrum = document.getElementById('scrFulcrum');
const scrStationary = document.getElementById('scrStationary');
const scrMoving = document.getElementById('scrMoving');
const scrLineA = document.getElementById('scrLineA');
const scrLineB = document.getElementById('scrLineB');

let target = null;
function setDotEl(el, p){
  if(!p){ el.style.display='none'; return; }
  el.setAttribute('cx', p.x); el.setAttribute('cy', p.y); el.style.display='block';
}
function setLineEl(el, a, b, onColor){
  if(a && b){
    el.setAttribute('x1', a.x); el.setAttribute('y1', a.y);
    el.setAttribute('x2', b.x); el.setAttribute('y2', b.y);
    el.style.display='block';
    if(onColor) el.setAttribute('stroke', onColor);
  } else el.style.display='none';
}

function refreshScreenDots(){
  setDotEl(scrFulcrum,   scr.fulcrum);
  setDotEl(scrStationary,scr.stationary);
  setDotEl(scrMoving,    scr.moving);
  setLineEl(scrLineA, scr.fulcrum, scr.stationary, '#ef4444');
  setLineEl(scrLineB, scr.fulcrum, scr.moving,    '#22c55e');

  const host = document.getElementById('gonioHost');
  const anyPlaced = !!(scr.fulcrum || scr.stationary || scr.moving);
  if (anyPlaced) { host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); }
  else           { host.classList.add('hide');    host.setAttribute('aria-hidden','true');  }

  if(scr.fulcrum && scr.stationary && scr.moving){
    const Fs = scr.fulcrum, Ss = scr.stationary, Ms = scr.moving;
    const baseDeg = Gonio.degFromScreenVec(Ss.x - Fs.x, Ss.y - Fs.y);
    const movDeg  = Gonio.degFromScreenVec(Ms.x - Fs.x, Ms.y - Fs.y);

    const inst = document.getElementById('instrument');
    const firstReveal = inst.style.display !== 'block';
    inst.style.display = 'block';

    if (firstReveal) {
      Gonio.setZoom(1);
      // make initial visual smaller so it never spawns huge
      const targetFrac = 0.18;
      const targetBound = Math.min(innerWidth, innerHeight) * targetFrac;
      const autoScale = Math.max(0.25, Math.min(0.9, targetBound / 140));
      Gonio.setScale(autoScale);
      sizeEl.value = Math.round(autoScale * 100);
    }

    Gonio.show();
    Gonio.setPose(Fs.x, Fs.y, baseDeg, movDeg);
    Gonio.zeroHere();
    // reset all controllers to 0 on first reveal
    rotateCWEl.value = 0; rotateCCWEl.value = 0; rotateMoveEl.value = 0;
    rotateGonioEl.value = Math.round(Gonio.getUserRot());
    const p = Gonio.getPan(); gonioXEl.value = Math.round(p.x); gonioYEl.value = Math.round(p.y);
    setAngleHUD(Gonio.angle, romString());
    setGonioLock(false);
  } else {
    document.getElementById('instrument').style.display = 'none';
  }
}

function pickOnScreen(e){
  if(!target) return;
  const leftPanel = document.querySelector('.panel');
  if(leftPanel && leftPanel.contains(e.target)) return;

  const r = renderer.domElement.getBoundingClientRect();
  const x = Math.min(Math.max(e.clientX - r.left, 0), r.width);
  const y = Math.min(Math.max(e.clientY - r.top, 0), r.height);

  scr[target] = { x, y };

  const host = document.getElementById('gonioHost');
  host.classList.remove('hide'); host.setAttribute('aria-hidden','false');
  log(`${target} pinned @ ${x|0},${y|0}`);
  target = null;
  refreshScreenDots();
}
renderer.domElement.addEventListener('pointerdown', pickOnScreen, {passive:false});
svg.addEventListener('pointerdown', pickOnScreen, {passive:false});

/* HUD + ROM */
function setAngleHUD(angle, romStr=""){
  hud.textContent = romStr ? `Angle: ${angle.toFixed(0)}¬∞ | ROM: ${romStr}` : `Angle: ${angle.toFixed(0)}¬∞`;
}
let romActive = false;
startROMBtn.onclick = ()=>{ Gonio.zeroHere(); rotateCWEl.value = 0; rotateCCWEl.value = 0; rotateMoveEl.value = 0; romActive = true; log(`ROM start @ 0¬∞`); };
resetROMBtn.onclick  = ()=>{ romActive = false; log(`ROM reset`); };
function romString(){ return romActive ? `${Gonio.angle.toFixed(0)}¬∞ (start 0¬∞)` : ""; }

/* Pills */
document.getElementById("pickFulcrum").onclick   = () => { target = "fulcrum";   log("Place Fulcrum");   };
document.getElementById("pickStationary").onclick= () => { target = "stationary";log("Place Stationary"); };
document.getElementById("pickMoving").onclick    = () => { target = "moving";    log("Place Moving");    };

/* Locks */
let lock3D=false, lockGonio=false;
function set3DLock(v){ lock3D=v; controls.enabled=!lock3D; lock3DBtn.textContent=(lock3D? "üîí 3D: Locked":"üîì 3D: Unlocked"); lock3DBtn.classList.toggle('lockOn', lock3D); }
function setGonioLock(v){
  lockGonio=v;
  document.getElementById('instrument').style.pointerEvents = lockGonio ? 'none' : 'auto';
  lockGonioBtn.textContent=(lockGonio? "üîí Gonio: Locked":"üîì Gonio: Unlocked");
  lockGonioBtn.classList.toggle('lockOn', lockGonio);
}
set3DLock(false); setGonioLock(false);
lock3DBtn.onclick = ()=> set3DLock(!lock3D);
lockGonioBtn.onclick = ()=> setGonioLock(!lockGonio);

/* Controllers */
const ctrlGonio = document.getElementById("ctrlGonio");
const ctrlModel = document.getElementById("ctrlModel");
[ctrlGonio, ctrlModel].forEach(d=>{
  d.addEventListener('toggle', ()=>{
    if (!d.open) return;
    if (d===ctrlGonio){ ctrlModel.open=false; set3DLock(true);  setGonioLock(false); }
    if (d===ctrlModel){ ctrlGonio.open=false; set3DLock(false); setGonioLock(true);  }
  });
});
document.getElementById("controllers").open = false;

/* Sliders */
sizeEl.oninput       = ()=> { Gonio.setScale(parseInt(sizeEl.value,10)/100); Gonio.refresh(); };

/* ===================== RUN ACTION (Step 3 wiring only) ===================== */
runActionBtn.onclick = () => {
  const key = motionSel.value;

  if (!key || key === "(No motions)") {
    log("‚ùå No valid motion selected.");
    return;
  }

  CURRENT_ACTION = ACTIONS.find(a => a.key === key);

  if (!CURRENT_ACTION) {
    log("‚ùå Action not found: " + key);
    return;
  }

  log(`üé¨ Ready to run action: ${CURRENT_ACTION.motion} (${CURRENT_ACTION.key})`);

  // Movement engine comes in Step 4
};

/* NEW: CW/CCW handlers (each zeroes the other) */
rotateCWEl.oninput = ()=>{
  if (lockGonio) return;
  const v = parseFloat(rotateCWEl.value)||0;
  rotateCCWEl.value = 0;
  rotateMoveEl.value = v;            // keep legacy in sync (unused in UI)
  Gonio.setMovDegRel(v);             // positive relative rotation
  setAngleHUD(Gonio.angle, romString());
};
rotateCCWEl.oninput = ()=>{
  if (lockGonio) return;
  const v = parseFloat(rotateCCWEl.value)||0;
  rotateCWEl.value = 0;
  rotateMoveEl.value = 0;            // legacy stays at 0 when CCW is used
  Gonio.setMovDegRel(-v);            // negative relative rotation
  setAngleHUD(Gonio.angle, romString());
};

rotateGonioEl.oninput= ()=>{ if (lockGonio) return; Gonio.setUserRot(parseFloat(rotateGonioEl.value)); setAngleHUD(Gonio.angle, romString()); };
gonioXEl.oninput     = ()=>{ const y = Gonio.getPan().y; Gonio.setPan(parseFloat(gonioXEl.value), y); };
gonioYEl.oninput     = ()=>{ const x = Gonio.getPan().x; Gonio.setPan(x, parseFloat(gonioYEl.value)); };

function applyModelTransform(){
  if(!model) return;
  model.position.x = parseFloat(modelX.value);
  model.position.z = parseFloat(modelZ.value);
  const s = parseInt(modelScale.value,10)/100;
  model.scale.setScalar(s);
  groundSnap();
  model.position.y += parseFloat(modelY.value);
  model.rotation.y = THREE.MathUtils.degToRad(parseFloat(modelYaw.value));
}
[modelX,modelZ,modelY,modelScale,modelYaw].forEach(el=> el.addEventListener('input', applyModelTransform));
resetPose.onclick = ()=>{
  modelX.value = "0"; modelZ.value = "0.6"; modelY.value = "0"; modelScale.value = "100"; modelYaw.value="0";
  applyModelTransform(); controls.target.set(0,1.1,0);
};

/* Reset Measurement */
resetMeasurementBtn.onclick = ()=>{
  scr.fulcrum = scr.stationary = scr.moving = null;
  refreshScreenDots();
  Gonio.hide(); romActive = false;
  rotateCWEl.value = 0; rotateCCWEl.value = 0; rotateMoveEl.value = 0; rotateGonioEl.value = 0;
  setAngleHUD(0,"");
  log("Measurement reset");
};

/* Render loop */
addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
});
const clock = new THREE.Clock();
(function animate(){
  clock.getDelta();
  controls.update();
  if (!document.getElementById('gonioHost').classList.contains('hide')) {
    setAngleHUD(Gonio.angle, romString());
  }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
})();

/* ===================== GONIOMETER MODULE ===================== */
const Gonio = (() => {
  const host  = document.getElementById('gonioHost');
  const svg   = document.getElementById('gonioSvg');
  const viewport   = document.getElementById('viewport');
  const rotWrap    = document.getElementById('rotWrap');
  const numsInWrap = document.getElementById('numsInWrap');
  const labelsFixed= document.getElementById('labelsFixed');
  const armA_ruler = document.getElementById('armA_ruler');
  const armB_ruler = document.getElementById('armB_ruler');

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const clamp360=a=>(a%360+360)%360;
  const toDegUp=(x,y)=>clamp360(Math.atan2(-y,x)*180/Math.PI+90);
  const shortest=(a,b)=>{ let d=clamp360(a-b); return d>180? 360-d: d; };

(function build(){
  const NS = "http://www.w3.org/2000/svg";
  const ticks   = document.getElementById('ticks');
  const numsOut = document.getElementById('numsOut');
  const numsIn  = document.getElementById('numsIn');

  const R   = 120;
  const Rin = 86;

  /* ---------- HELPERS ---------- */
  const line = (p,x1,y1,x2,y2,cls)=>{
    const n = document.createElementNS(NS,'line');
    n.setAttribute('x1',x1); n.setAttribute('y1',y1);
    n.setAttribute('x2',x2); n.setAttribute('y2',y2);
    if (cls) n.setAttribute('class',cls);
    p.appendChild(n);
  };

  const text = (p,x,y,t,cls)=>{
    const n = document.createElementNS(NS,'text');
    n.setAttribute('x',x); n.setAttribute('y',y);
    n.setAttribute('class',cls);
    n.textContent = t;
    p.appendChild(n);
    return n;
  };

  // map tick-angle d (0=top, 90=right, 180=bottom, 270=left)
  // ‚Üí inner goniometer degrees with 0 at BOTTOM, 180 at TOP
  const innerFromD = (d)=>{
    const raw = (d + 180) % 360;      // put 0 at bottom
    return (raw <= 180) ? raw : 360 - raw;  // 0 ‚Üí 180 ‚Üí 0
  };

  /* ---------- TICKS: band between inner & outer labels ---------- */
  const rBand = (R + Rin) * 0.5;      // middle between inner & outer rings

  for (let d = 0; d < 360; d += 5){
    const a   = (d - 90) * Math.PI / 180;
    const big = (d % 10 === 0);       // long every 10¬∞, medium every 5¬∞
    const len = big ? 12 : 6;

    const r1 = rBand - len * 0.5;
    const r2 = rBand + len * 0.5;

    line(
      ticks,
      Math.cos(a) * r1,
      Math.sin(a) * r1,
      Math.cos(a) * r2,
      Math.sin(a) * r2,
      big ? "tick tickBig" : "tick"
    );
  }

  /* ---------- OUTER + INNER NUMBERS ---------- */
  numsOut.innerHTML = "";
  numsIn.innerHTML  = "";

  const rWhite = R   - 8;   // outer-number radius
  const rInner = Rin + 9;   // inner-number radius

   /* ---------- OUTER (0‚Äì80‚Äì0‚Äì80‚Äì0) ---------- */
  const OUTER_ANGLE_SHIFT = +20;   // <‚Äî rotate outer labels by 20¬∞

  for (let d = 0; d < 360; d += 10){
    const inner = innerFromD(d);
    const outer = Math.abs(90 - inner);       // complement

    if (outer % 20 !== 0 || outer > 80) continue; // only 0,20,40,60,80

    // apply 20¬∞ shift ONLY to outer label positions
    const a = (d - 90 + OUTER_ANGLE_SHIFT) * Math.PI / 180;
    const x = Math.cos(a) * rWhite;
    const y = Math.sin(a) * rWhite;

    text(numsOut, x, y, String(outer), "labelOuter");
  }

  /* INNER: 0 ‚Üí 180 ‚Üí 0, with 0 ONLY at the bottom
     (so inner 0,10,20,‚Ä¶,170,180,170,‚Ä¶,10)
  */
  for (let d = 0; d < 360; d += 10){
    const inner = innerFromD(d);

    if (inner % 10 !== 0) continue;          // every 10¬∞
    if (inner === 0 && d !== 180) continue;  // single 0 at bottom only

    const a = (d - 90) * Math.PI / 180;
    const x = Math.cos(a) * rInner;
    const y = Math.sin(a) * rInner;

    text(numsIn, x, y, String(inner), "labelInner");
  }


    buildTipRuler(armA_ruler, +380, +1, 'A');
    buildTipRuler(armB_ruler, -380, -1, 'B');
    function buildTipRuler(group, tipY, dir, which){
      const CM_TO_PX = 14, IN_TO_CM = 2.5;
      group.innerHTML='';
      const line2=(x1,y1,x2,y2)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','line');n.setAttribute('x1',x1);n.setAttribute('y1',y1);n.setAttribute('x2',x2);n.setAttribute('y2',y2);n.setAttribute('class','rulerTick');group.appendChild(n);};
      const label=(x,y,t,rot)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','text');n.setAttribute('x',x);n.setAttribute('y',y);n.setAttribute('class','ruLbl'); if(rot) n.setAttribute('transform',`rotate(${rot} ${x} ${y})`); n.textContent=t; n.dataset.arm=which; n.dataset.x=x; n.dataset.y=y; group.appendChild(n); return n;};
      const cmMax=15, inMax=6;
      for(let cm=0; cm<=cmMax+1e-6; cm+=0.5){
        const y = tipY - dir*(cm*CM_TO_PX);
        const long = Math.abs(cm - Math.round(cm)) < 1e-6;
        const mid  = !long && Math.abs(cm*2 - Math.round(cm*2)) < 1e-6;
        const w = long?8:mid?5:3; line2(-10,y,-10-w,y);
        if (long) label(-18,y,String(Math.round(cm)),-90);
      }
      for(let inch=0; inch<=inMax+1e-6; inch+=0.5){
        const y = tipY - dir*(inch*IN_TO_CM*CM_TO_PX);
        const long = Math.abs(inch - Math.round(inch)) < 1e-6;
        const mid  = !long && Math.abs(inch*2 - Math.round(inch*2)) < 1e-6;
        const w = long?8:mid?5:3; line2(10,y,10+w,y);
        if (long) label(18,y,String(Math.round(inch)),90);
      }
      label(-26,tipY,'cm',-90); label(26,tipY,'in',90);
    }
  })();

  let mov=30, zoom=1, panX=innerWidth/2, panY=innerHeight/2;
  let baseRot=0, userRot=0, scale=1;
  let zeroRef=0;
  let draggingArm=false, draggingPan=false, lastPanScreen=null;

  function applyView(){ viewport.setAttribute('transform',`translate(${panX},${panY}) scale(${zoom*scale})`); }
  function applyRot(){ rotWrap.setAttribute('transform',`rotate(${baseRot+userRot})`); }
  function applyLabelFix(){ const t=-(baseRot+userRot); labelsFixed.setAttribute('transform',`rotate(${t})`); numsInWrap.setAttribute('transform',`rotate(${-t})`); }
  function updateRulerUpright(){
    const labels = document.querySelectorAll('.ruLbl');
    labels.forEach(t=>{
      const which=t.dataset.arm;
      const base = (which==='A'? 0 : mov) + baseRot + userRot;
      const x=+t.dataset.x, y=+t.dataset.y;
      t.setAttribute('transform', `rotate(${-base} ${x} ${y})`);
    });
  }

  /* --- KEY FIX: allow full up/down pan (very loose clamp) --- */
  function clampPanToViewport(){
    const bound   = 80 * zoom * scale; // smaller radius budget
    const margin  = 6;                 // tiny gutter
    const minX = margin + bound, maxX = innerWidth  - margin - bound;
    const minY = margin + bound, maxY = innerHeight - margin - bound;
    if (minX <= maxX) panX = Math.min(maxX, Math.max(minX, panX)); else panX = innerWidth/2;
    if (minY <= maxY) panY = Math.min(maxY, Math.max(minY, panY)); else panY = innerHeight/2;
  }
  function clampNow(){ clampPanToViewport(); applyView(); }

  function render(){
    document.getElementById('armA_grp').setAttribute('transform','rotate(0)');
    document.getElementById('armB_grp').setAttribute('transform',`rotate(${mov})`);
    updateRulerUpright();
  }
  clampPanToViewport(); applyView(); applyRot(); applyLabelFix(); render();

  /* Pan by dragging anywhere on the instrument (except moving-arm handles) */
  const instrument = document.getElementById('instrument');
  instrument.addEventListener('pointerdown', e=>{
    if (lockGonio) return;
    // ignore if grabbing the green arm handle/shaft/knob
    if (e.target.closest('#armB_handleKnob') || e.target.closest('#armB_handleShaft') || e.target.closest('#armB_knob')) return;
    e.preventDefault(); draggingPan = true;
    lastPanScreen = { x: e.clientX, y: e.clientY };
    instrument.setPointerCapture?.(e.pointerId);
  });
  instrument.addEventListener('pointermove', e=>{
    if (lockGonio) return;
    if (!draggingPan || !lastPanScreen) return;
    e.preventDefault();
    const dx = (e.clientX - lastPanScreen.x) / (zoom * scale);
    const dy = (e.clientY - lastPanScreen.y) / (zoom * scale);
    panX += dx; panY += dy;
    lastPanScreen = { x: e.clientX, y: e.clientY };
    clampPanToViewport(); applyView();
  });
  instrument.addEventListener('pointerup',   ()=>{ draggingPan=false; lastPanScreen=null; });
  instrument.addEventListener('pointercancel',()=>{ draggingPan=false; lastPanScreen=null; });

  /* Wheel zoom */
  svg.addEventListener('wheel', e=>{
    if (lockGonio) return;
    e.preventDefault();
    const step = Math.sign(e.deltaY) < 0 ? 1.22 : 1/1.22;
    zoom = clamp(zoom * step, 0.07, 10);
    clampPanToViewport(); applyView();
  }, {passive:false});

  /* Drag moving arm (visual), full 360 */
  function startArmDrag(e){
    if (lockGonio) return;
    e.stopPropagation(); e.preventDefault();
    document.getElementById('armB_grp').setPointerCapture?.(e.pointerId);
    draggingArm = true;
  }
  function moveArm(e){
    if (lockGonio) return;
    if(!draggingArm) return;
    e.stopPropagation(); e.preventDefault();
    const pt = svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const p = pt.matrixTransform(rotWrap.getScreenCTM().inverse());
    mov = toDegUp(p.x, p.y); // 0..360
    render();
  }
  function endArm(){ draggingArm=false; }

  ['armB_handleKnob','armB_handleShaft','armB_grp','armB_knob'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    el.addEventListener('pointerdown', startArmDrag);
    el.addEventListener('pointermove', moveArm);
    el.addEventListener('pointerup', endArm);
    el.addEventListener('pointercancel', endArm);
  });

  function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); clampPanToViewport(); applyView(); }
  function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); }

  // baseDeg=stationary vector; movDeg=moving vector (absolute screen angles)
  function setPose(cx,cy,baseDeg,movDeg){
    panX=cx; panY=cy; baseRot=baseDeg; mov=clamp360(movDeg-baseDeg);
    clampPanToViewport(); applyView(); applyRot(); applyLabelFix(); render();
  }

  function setScale(k){ scale=clamp(k||1,0.1,2); clampPanToViewport(); applyView(); }
  function setZoom(k){  zoom =clamp(k||1,0.07,10); clampPanToViewport(); applyView(); }
  function degFromScreenVec(dx,dy){ return toDegUp(dx,dy); }

  // Relative-zero API
  function zeroHere(){ zeroRef = clamp360(mov); }
  function setMovDegRel(deg){ mov = clamp360(zeroRef + deg); render(); }
  function setMovDegAbs(deg){ mov = clamp360(deg); render(); }
  function setUserRot(deg){ userRot = clamp360(deg); applyRot(); applyLabelFix(); render(); }
  function getUserRot(){ return clamp360(userRot); }
  function getMovDegAbs(){ return clamp360(mov); }

  // pan getters/setters for sliders
  function setPan(x,y){ panX = x; panY = y; clampPanToViewport(); applyView(); }
  function getPan(){ return { x: panX, y: panY }; }

  // Angle is shortest arc from zeroRef to mov (<=180¬∞)
  function currentAngle(){ return shortest(mov, zeroRef); }

  return {
    show, hide, setPose, setScale, setZoom, degFromScreenVec, _clampNow:clampNow,
    zeroHere, setMovDegRel, setMovDegAbs, setUserRot, getUserRot, getMovDegAbs,
    setPan, getPan,
    get angle(){ return currentAngle(); },
    refresh: ()=>{ applyView(); applyRot(); applyLabelFix(); render(); }
  };
})();
window.Gonio = Gonio;

/* ===================== NOTES LOADER (Markdown) ===================== */
function mdToHtml(md){
  let html = md
    .replace(/^### (.*)$/gm, '<h5>$1</h5>')
    .replace(/^## (.*)$/gm, '<h4>$1</h4>')
    .replace(/^# (.*)$/gm, '<h3>$1</h3>')
    .replace(/^\* (.*)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>');
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  return html;
}
async function loadNote(region, motion){
  const url = `./goniometer-placement-guide/${region}.md?${Date.now()}`;
  try{
    const res = await fetch(url);
    if(!res.ok){ throw new Error(`HTTP ${res.status}`); }
    const md = await res.text();
    const re = new RegExp(`(^|\\n)##?\\s*${motion}\\s*\\n([\\s\\S]*?)(\\n##?\\s|$)`,'i');
    const m = md.match(re);
    const section = m ? m[2].trim() : md;
    noteTitle.textContent = `${regionToTitle(region)} ‚Äî ${motion}`;
    noteBody.innerHTML = mdToHtml(section || "‚Äî");
  }catch(e){
    console.error(e);
    noteTitle.textContent = `${regionToTitle(region)} ‚Äî ${motion}`;
    noteBody.textContent = "Failed to load note.";
  }
}
function regionToTitle(r){
  return ({
    cervical_spine:"Cervical Spine",
    thoracic_lumbar_spine:"Thoracic & Lumbar Spine",
    glenohumeral_joint:"Glenohumeral Joint",
    elbow_radioulnar:"Elbow & Radioulnar Joints",
    wrist:"Wrist", hip:"Hip", knee:"Knee",
    talocrural_ankle:"Talocrural (Ankle)",
    transverse_tarsal_subtalar:"Transverse Tarsal & Subtalar",
    fingers_mcp_pip_dip:"Fingers (MCP, PIP, DIP)",
    thumb_cmc_mcp_ip:"Thumb (CMC, MCP, IP)",
    toes_mtp_pip_dip:"Toes (MTP, PIP, DIP)"
  }[r]||r.replace(/_/g,' '));
}
document.getElementById("showNote").onclick = async ()=>{
  const region = regionSel.value;
  const motion = motionSel.value || "(General)";
  await loadNote(region, motion);
  note.classList.remove("hide");
};

/* Errors */
window.addEventListener('error', e => { msg.textContent = '‚ùå ' + (e.message || 'Script error'); console.error(e); });
</script>
</body>
</html>
