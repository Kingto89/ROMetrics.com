<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Digital Goniometer</title>
<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto}
  .bar{position:fixed;top:0;left:0;right:0;display:flex;gap:12px;justify-content:center;align-items:center;padding:8px 12px;background:#0b1220cc;border-bottom:1px solid #1f2937;backdrop-filter:blur(6px);z-index:10;font-weight:700}
  .btn{background:#0f172a;border:1px solid #334155;color:#e5e7eb;border-radius:10px;padding:6px 10px;cursor:pointer}
  #stage{position:fixed;inset:0}
  svg{width:100vw;height:100vh;touch-action:none;background:transparent}

  .tick{stroke:#64748b;stroke-width:.9}
  .tickBig{stroke-width:1.6}

  /* Stationary = RED, Moving = GREEN */
  .armA{stroke:#ef4444;fill:none}
  .armB{stroke:#22c55e;fill:none}
  .knobA{fill:#ef4444}
  .knobB{fill:#22c55e}

  .axisA{stroke:#ef4444;stroke-width:1.6;opacity:.85}
  .axisB{stroke:#22c55e;stroke-width:1.6;opacity:.85}

  .rulerTick{stroke:#94a3b8}
  .handle{cursor:grab} .handle:active{cursor:grabbing}

  .labelOuter{fill:#e5e7eb;font-size:11px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .labelInner{fill:#fca5a5;font-size:8.2px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .ruLbl{fill:#cbd5e1;font-size:9.5px;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
</style>

<div class="bar">
  <div>Angle (0–180°): <span id="a180">0°</span></div>
  <div>|</div>
  <div>Angle (0–360°): <span id="a360">0°</span></div>
  <button id="zero" class="btn">Zero at current</button>
  <button id="reset" class="btn">Reset</button>
  <span style="font-weight:600;opacity:.85">Touch: pinch zoom • 2-finger pan/rotate • double-tap to flip • drag green arm</span>
</div>

<div id="stage">
  <svg id="svg" aria-label="Universal goniometer">
    <g id="viewport" transform="translate(0,0) scale(1)">
      <g id="rotWrap" transform="rotate(0)">
        <g id="mirrorWrap" transform="scale(1,1)">
          <g id="instrument">
            <g id="head">
              <circle r="120" fill="#0f172a" stroke="#94a3b8" stroke-width="1.6"/>
              <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
              <g id="ticks"></g>

              <g id="labelsFixed">
                <g id="numsOut"></g>
                <g id="numsInWrap">
                  <g id="numsIn"></g>
                </g>
              </g>

              <circle r="3.2" fill="#94a3b8"/>
            </g>

            <!-- RED stationary arm (non-draggable) -->
            <g id="armA_grp">
              <rect class="armA" x="-10" y="120" width="20" height="260" rx="10" stroke-width="3"/>
              <line id="axisA" class="axisA" x1="0" y1="380" x2="0" y2="-116" stroke-linecap="round"/>
              <g id="armA_ruler"></g>
              <circle id="armA_knob" cx="0" cy="380" r="10" class="knobA"/>
            </g>

            <!-- GREEN moving arm (draggable) -->
            <g id="armB_grp" class="handle">
              <rect class="armB" x="-10" y="-380" width="20" height="500" rx="10" stroke-width="3"/>
              <line id="axisB" class="axisB" x1="0" y1="-380" x2="0" y2="124" stroke-linecap="round"/>
              <g id="armB_ruler"></g>
              <circle id="armB_knob" cx="0" cy="-380" r="10" class="knobB"/>
            </g>
          </g>
        </g>
      </g>
    </g>
  </svg>
</div>

<script>
(()=>{
  const svg = document.getElementById('svg');
  const viewport   = document.getElementById('viewport');
  const rotWrap    = document.getElementById('rotWrap');
  const mirrorWrap = document.getElementById('mirrorWrap');

  const clamp360 = a => (a%360+360)%360;
  const toDegUp  = (x,y)=> clamp360(Math.atan2(-y,x)*180/Math.PI + 90); // 0° = up
  const R=120, Rin=86;

  // Elements
  const ticks=document.getElementById('ticks');
  const labelsFixed=document.getElementById('labelsFixed');
  const numsOut=document.getElementById('numsOut');
  const numsInWrap=document.getElementById('numsInWrap');
  const numsIn=document.getElementById('numsIn');
  const armA_grp=document.getElementById('armA_grp');
  const armB_grp=document.getElementById('armB_grp');
  const armA_ruler=document.getElementById('armA_ruler');
  const armB_ruler=document.getElementById('armB_ruler');
  const a180=document.getElementById('a180'), a360=document.getElementById('a360');
  const zeroBtn=document.getElementById('zero'), resetBtn=document.getElementById('reset');

  /* ticks */
  for(let d=0; d<360; d+=5){
    const a=(d-90)*Math.PI/180, big=d%30===0, len=big?12:6;
    line(ticks, Math.cos(a)*(R-len), Math.sin(a)*(R-len), Math.cos(a)*R, Math.sin(a)*R, big?'tick tickBig':'tick');
  }

  /* OUTER white labels: 0 at 90° & 270°, then 20/40/60/80 outward */
  const rWhite = R - 8;
  for (let d = 0; d < 360; d += 10) {
    const diff90  = Math.abs(((d - 90)  % 360 + 540) % 360 - 180);
    const diff270 = Math.abs(((d - 270) % 360 + 540) % 360 - 180);
    const val = Math.min(diff90, diff270);
    if (val % 20 === 0 && val <= 80) {
      const a=(d-90)*Math.PI/180, x=Math.cos(a)*rWhite, y=Math.sin(a)*rWhite;
      text(numsOut, x, y, String(val), 'labelOuter');
    }
  }

  /* INNER red labels (0→180→0), evenly on inner rim */
  const valFromTheta = th => {
    const t = (th + 180) % 360;        // 0 at neck
    return t <= 180 ? t : 360 - t;     // 0..180..0
  };
  const rInnerText = Rin + 9;
  for(let th=0; th<360; th+=10){
    const val = valFromTheta(th);
    const show = (val % 10 === 0);
    const txt = (val===0 && th!==180) ? '' : (show ? val : '');
    if (!txt) continue;
    const a=(th-90)*Math.PI/180, x=Math.cos(a)*rInnerText, y=Math.sin(a)*rInnerText;
    text(numsIn, x, y, String(txt), 'labelInner');
  }
  /* single centered 0 at neck */
  {
    const thZero = 180; const a0=(thZero-90)*Math.PI/180;
    const x0=Math.cos(a0)*rInnerText, y0=Math.sin(a0)*rInnerText;
    text(numsIn, x0, y0, '0', 'labelInner');
  }

  /* rulers */
  const CM_TO_PX = 14, IN_TO_CM = 2.5;
  const tipY_red= 380, tipY_green=-380;
  buildTipRuler(armA_ruler, tipY_red, +1, 'A');
  buildTipRuler(armB_ruler, tipY_green, -1, 'B');

  function buildTipRuler(group, tipY, dir, which){
    group.innerHTML='';
    const cmMax=15, inMax=6;
    for(let cm=0; cm<=cmMax+1e-6; cm+=0.5){
      const y = tipY - dir*(cm*CM_TO_PX);
      const long = Math.abs(cm - Math.round(cm)) < 1e-6;
      const mid  = !long && Math.abs(cm*2 - Math.round(cm*2)) < 1e-6;
      const w = long?8:mid?5:3;
      line(group, -10, y, -10-w, y, 'rulerTick');
      if (long){ const t=text(group,-18,y,Math.round(cm),'ruLbl',-90); t.dataset.arm=which; t.dataset.x=-18; t.dataset.y=y; }
    }
    for(let inch=0; inch<=inMax+1e-6; inch+=0.5){
      const y = tipY - dir*(inch*IN_TO_CM*CM_TO_PX);
      const long = Math.abs(inch - Math.round(inch)) < 1e-6;
      const mid  = !long && Math.abs(inch*2 - Math.round(inch*2)) < 1e-6;
      const w = long?8:mid?5:3;
      line(group, 10, y, 10+w, y, 'rulerTick');
      if (long){ const t=text(group,18,y,Math.round(inch),'ruLbl',90); t.dataset.arm=which; t.dataset.x=18; t.dataset.y=y; }
    }
    const tcm=text(group,-26,tipY,'cm','ruLbl',-90); tcm.dataset.arm=which; tcm.dataset.x=-26; tcm.dataset.y=tipY;
    const tin=text(group, 26,tipY,'in','ruLbl', 90); tin.dataset.arm=which; tin.dataset.x= 26; tin.dataset.y=tipY;
  }

  /* state / transforms */
  let mov=0;
  let gRot=0, zoom=1, panX=0, panY=0, mirrored=false;

  function applyView(){ viewport.setAttribute('transform', `translate(${panX},${panY}) scale(${zoom})`); }
  function applyRot(){ rotWrap.setAttribute('transform', `rotate(${gRot})`); }
  function applyMirror(){ mirrorWrap.setAttribute('transform', `scale(${mirrored?-1:1},1)`); }
  function applyLabelFix(){
    const sx = mirrored ? -1 : 1;
    labelsFixed.setAttribute('transform', `scale(${sx},1) rotate(${-gRot})`);
    numsInWrap.setAttribute('transform', `rotate(${sx * gRot})`);
  }

  /* drag green only — no jump on click */
  let dragging=null;
  function getPointIn(node, clientX, clientY){
    const pt = svg.createSVGPoint(); pt.x=clientX; pt.y=clientY;
    return pt.matrixTransform(node.getScreenCTM().inverse());
  }
  function onPointerDown(e){
    if (e.target.closest('#armB_grp')) {
      dragging='B';
      svg.setPointerCapture?.(e.pointerId);
      // NOTE: do NOT update angle here -> prevents single-click jump
    } else dragging=null;
  }
  function onPointerMove(e){
    if(dragging!=='B') return;
    const p = getPointIn(rotWrap, e.clientX, e.clientY);
    let deg = toDegUp(p.x, p.y);
    mov = deg; render();
  }
  function onPointerUp(){ dragging=null; }
  svg.addEventListener('pointerdown', onPointerDown);
  svg.addEventListener('pointermove', onPointerMove);
  svg.addEventListener('pointerup', onPointerUp);
  svg.addEventListener('pointercancel', onPointerUp);

  /* gestures: pinch zoom + 2-finger pan/rotate */
  let touches=new Map(), lastGesture=null;
  const tp = e => ({x:e.clientX,y:e.clientY});
  const ctr=(a,b)=>({x:(a.x+b.x)/2,y:(a.y+b.y)/2});
  const dst=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const ang=(a,b)=>Math.atan2(b.y-a.y,b.x-a.x)*180/Math.PI;

  svg.addEventListener('pointerdown', e=>{ if(e.pointerType==='touch'){ touches.set(e.pointerId, tp(e)); startG(); }});
  svg.addEventListener('pointermove', e=>{ if(e.pointerType==='touch' && touches.has(e.pointerId)){ touches.set(e.pointerId, tp(e)); moveG(); }});
  svg.addEventListener('pointerup',   e=>{ if(touches.delete(e.pointerId)) endG(); });
  svg.addEventListener('pointercancel', e=>{ if(touches.delete(e.pointerId)) endG(); });

  function startG(){ if(touches.size===2){ const [a,b]=[...touches.values()]; lastGesture={c:ctr(a,b), d:dst(a,b), a:ang(a,b), panX, panY, zoom, gRot}; } }
  function moveG(){
    if(touches.size!==2 || !lastGesture) return;
    const [a,b]=[...touches.values()];
    const c=ctr(a,b), d=dst(a,b), ag=ang(a,b);
    zoom = Math.min(4, Math.max(0.4, lastGesture.zoom*(d/lastGesture.d)));
    panX = lastGesture.panX + (c.x - lastGesture.c.x)/zoom;
    panY = lastGesture.panY + (c.y - lastGesture.c.y)/zoom;
    let da = ag - lastGesture.a; while(da>180) da-=360; while(da<-180) da+=360;
    gRot = lastGesture.gRot + da;
    applyView(); applyRot(); applyLabelFix(); render();
  }
  function endG(){ lastGesture=null; }

  /* double-tap flip still available */
  let lastTap=0;
  svg.addEventListener('pointerdown', e=>{
    if (e.pointerType!=='touch') return;
    const now=performance.now();
    if (now-lastTap<300){ mirrored=!mirrored; applyMirror(); applyLabelFix(); render(); lastTap=0; }
    else lastTap=now;
  });

  /* wheel zoom fallback */
  svg.addEventListener('wheel', e=>{
    e.preventDefault();
    const fac = e.deltaY>0 ? 1/1.1 : 1.1;
    const pt = getPointIn(viewport, e.clientX, e.clientY);
    const newZoom = Math.min(4, Math.max(0.4, zoom*fac));
    const k = newZoom/zoom;
    panX = pt.x - k*(pt.x - panX);
    panY = pt.y - k*(pt.y - panY);
    zoom = newZoom; applyView();
  }, {passive:false});

  function render(){
    armA_grp.setAttribute('transform', `rotate(0)`);
    armB_grp.setAttribute('transform', `rotate(${mov})`);
    document.querySelectorAll('.ruLbl').forEach(t=>{
      const which=t.dataset.arm; const base = (which==='A'? 0 : mov) + gRot;
      const x=+t.dataset.x, y=+t.dataset.y;
      t.setAttribute('transform', `rotate(${-base} ${x} ${y})`);
    });
    const d360 = clamp360(mov);
    const d180 = d360>180 ? 360-d360 : d360;
    a180.textContent = Math.round(d180)+'°';
    a360.textContent = Math.round(d360)+'°';
  }

  /* init */
  applyView(); applyRot(); applyMirror(); applyLabelFix(); render();

  zeroBtn.onclick = ()=>{};
  resetBtn.onclick= ()=>{ mov=0; gRot=0; zoom=1; panX=0; panY=0; mirrored=false;
                          applyView(); applyRot(); applyMirror(); applyLabelFix(); render(); };

  /* helpers */
  function line(parent,x1,y1,x2,y2,cls){
    const n=document.createElementNS('http://www.w3.org/2000/svg','line');
    n.setAttribute('x1',x1); n.setAttribute('y1',y1);
    n.setAttribute('x2',x2); n.setAttribute('y2',y2);
    if (cls) n.setAttribute('class',cls); parent.appendChild(n);
  }
  function text(parent,x,y,str,cls,rot){
    const n=document.createElementNS('http://www.w3.org/2000/svg','text');
    n.setAttribute('x',x); n.setAttribute('y',y);
    n.setAttribute('class',cls||'labelOuter');
    if (rot) n.setAttribute('transform',`rotate(${rot} ${x} ${y})`);
    n.textContent=str; parent.appendChild(n); return n;
  }
})();
</script>
</html>
